import {
  require_react_dom
} from "./chunk-ETSZ6GDY.js";
import {
  __toESM,
  require_react
} from "./chunk-IM5P2SCX.js";

// node_modules/@coreui/react/dist/index.es.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());
var import_react_dom = __toESM(require_react_dom());
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var propTypes = { exports: {} };
var reactIs = { exports: {} };
var reactIs_development = {};
var hasRequiredReactIs_development;
function requireReactIs_development() {
  if (hasRequiredReactIs_development)
    return reactIs_development;
  hasRequiredReactIs_development = 1;
  if (true) {
    (function() {
      var hasSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
      function isValidElementType(type) {
        return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object) {
        if (typeof object === "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return void 0;
      }
      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element2 = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement2(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      reactIs_development.AsyncMode = AsyncMode;
      reactIs_development.ConcurrentMode = ConcurrentMode;
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element2;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement2;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }
  return reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs)
    return reactIs.exports;
  hasRequiredReactIs = 1;
  (function(module) {
    if (false) {
      module.exports = requireReactIs_production_min();
    } else {
      module.exports = requireReactIs_development();
    }
  })(reactIs);
  return reactIs.exports;
}
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var has;
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas)
    return has;
  hasRequiredHas = 1;
  has = Function.call.bind(Object.prototype.hasOwnProperty);
  return has;
}
var checkPropTypes_1;
var hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var printWarning = function() {
  };
  if (true) {
    var ReactPropTypesSecret = requireReactPropTypesSecret();
    var loggedTypeFailures = {};
    var has2 = requireHas();
    printWarning = function(text) {
      var message = "Warning: " + text;
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x) {
      }
    };
  }
  function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {
    if (true) {
      for (var typeSpecName in typeSpecs) {
        if (has2(typeSpecs, typeSpecName)) {
          var error;
          try {
            if (typeof typeSpecs[typeSpecName] !== "function") {
              var err = Error(
                (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              err.name = "Invariant Violation";
              throw err;
            }
            error = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }
          if (error && !(error instanceof Error)) {
            printWarning(
              (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
            );
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : "";
            printWarning(
              "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
            );
          }
        }
      }
    }
  }
  checkPropTypes.resetWarningCache = function() {
    if (true) {
      loggedTypeFailures = {};
    }
  };
  checkPropTypes_1 = checkPropTypes;
  return checkPropTypes_1;
}
var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var ReactIs = requireReactIs();
  var assign = requireObjectAssign();
  var ReactPropTypesSecret = requireReactPropTypesSecret();
  var has2 = requireHas();
  var checkPropTypes = requireCheckPropTypes();
  var printWarning = function() {
  };
  if (true) {
    printWarning = function(text) {
      var message = "Warning: " + text;
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x) {
      }
    };
  }
  function emptyFunctionThatReturnsNull() {
    return null;
  }
  factoryWithTypeCheckers = function(isValidElement2, throwOnDirectAccess) {
    var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === "function") {
        return iteratorFn;
      }
    }
    var ANONYMOUS = "<<anonymous>>";
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker("array"),
      bigint: createPrimitiveTypeChecker("bigint"),
      bool: createPrimitiveTypeChecker("boolean"),
      func: createPrimitiveTypeChecker("function"),
      number: createPrimitiveTypeChecker("number"),
      object: createPrimitiveTypeChecker("object"),
      string: createPrimitiveTypeChecker("string"),
      symbol: createPrimitiveTypeChecker("symbol"),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };
    function is(x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function PropTypeError(message, data) {
      this.message = message;
      this.data = data && typeof data === "object" ? data : {};
      this.stack = "";
    }
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
      if (true) {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;
        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            var err = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            err.name = "Invariant Violation";
            throw err;
          } else if (typeof console !== "undefined") {
            var cacheKey = componentName + ":" + propName;
            if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
              printWarning(
                "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
              );
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
            }
            return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
          }
          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }
      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          var preciseType = getPreciseType(propValue);
          return new PropTypeError(
            "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
            { expectedType }
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
        }
        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!isValidElement2(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!ReactIs.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        if (true) {
          if (arguments.length > 1) {
            printWarning(
              "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
            );
          } else {
            printWarning("Invalid argument supplied to oneOf, expected an array.");
          }
        }
        return emptyFunctionThatReturnsNull;
      }
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }
        var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
          var type = getPreciseType(value);
          if (type === "symbol") {
            return String(value);
          }
          return value;
        });
        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
      }
      return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== "function") {
          return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
        }
        for (var key in propValue) {
          if (has2(propValue, key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
        return emptyFunctionThatReturnsNull;
      }
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (typeof checker !== "function") {
          printWarning(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
          );
          return emptyFunctionThatReturnsNull;
        }
      }
      function validate(props, propName, componentName, location, propFullName) {
        var expectedTypes = [];
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker2 = arrayOfTypeCheckers[i2];
          var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
          if (checkerResult == null) {
            return null;
          }
          if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
            expectedTypes.push(checkerResult.data.expectedType);
          }
        }
        var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
        return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
      }
      return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function invalidValidatorError(componentName, location, propFullName, key, type) {
      return new PropTypeError(
        (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
      );
    }
    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (typeof checker !== "function") {
            return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
          }
          var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== "object") {
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
        }
        var allKeys = assign({}, props[propName], shapeTypes);
        for (var key in allKeys) {
          var checker = shapeTypes[key];
          if (has2(shapeTypes, key) && typeof checker !== "function") {
            return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
          }
          if (!checker) {
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
            );
          }
          var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
      switch (typeof propValue) {
        case "number":
        case "string":
        case "undefined":
          return true;
        case "boolean":
          return !propValue;
        case "object":
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || isValidElement2(propValue)) {
            return true;
          }
          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              while (!(step = iterator.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }
          return true;
        default:
          return false;
      }
    }
    function isSymbol(propType, propValue) {
      if (propType === "symbol") {
        return true;
      }
      if (!propValue) {
        return false;
      }
      if (propValue["@@toStringTag"] === "Symbol") {
        return true;
      }
      if (typeof Symbol === "function" && propValue instanceof Symbol) {
        return true;
      }
      return false;
    }
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return "array";
      }
      if (propValue instanceof RegExp) {
        return "object";
      }
      if (isSymbol(propType, propValue)) {
        return "symbol";
      }
      return propType;
    }
    function getPreciseType(propValue) {
      if (typeof propValue === "undefined" || propValue === null) {
        return "" + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === "object") {
        if (propValue instanceof Date) {
          return "date";
        } else if (propValue instanceof RegExp) {
          return "regexp";
        }
      }
      return propType;
    }
    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);
      switch (type) {
        case "array":
        case "object":
          return "an " + type;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + type;
        default:
          return type;
      }
    }
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithTypeCheckers;
}
if (true) {
  ReactIs = requireReactIs();
  throwOnDirectAccess = true;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else {
  propTypes.exports = requireFactoryWithThrowingShims()();
}
var ReactIs;
var throwOnDirectAccess;
var classnames = { exports: {} };
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames2() {
      var classes = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes.push(arg.toString());
            continue;
          }
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classNames = classnames.exports;
var CAccordionContext = (0, import_react.createContext)({});
var CAccordion = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, _b = _a.activeItemKey, activeItemKey = _b === void 0 ? void 0 : _b, _c = _a.alwaysOpen, alwaysOpen = _c === void 0 ? false : _c, className = _a.className, flush = _a.flush, rest = __rest(_a, ["children", "activeItemKey", "alwaysOpen", "className", "flush"]);
  var _d = (0, import_react.useState)(activeItemKey), _activeItemKey = _d[0], setActiveKey = _d[1];
  var _className = classNames("accordion", { "accordion-flush": flush }, className);
  return import_react.default.createElement(
    "div",
    __assign({ className: _className }, rest, { ref }),
    import_react.default.createElement(CAccordionContext.Provider, { value: { _activeItemKey, alwaysOpen, setActiveKey } }, children2)
  );
});
CAccordion.propTypes = {
  alwaysOpen: propTypes.exports.bool,
  activeItemKey: propTypes.exports.oneOfType([propTypes.exports.number, propTypes.exports.string]),
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  flush: propTypes.exports.bool
};
CAccordion.displayName = "CAccordion";
var CAccordionItemContext = (0, import_react.createContext)({});
var CAccordionItem = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, itemKey = _a.itemKey, rest = __rest(_a, ["children", "className", "itemKey"]);
  var _itemKey = (0, import_react.useRef)(itemKey ? itemKey : Math.random().toString(36).substr(2, 9));
  var _b = (0, import_react.useContext)(CAccordionContext), _activeItemKey = _b._activeItemKey, alwaysOpen = _b.alwaysOpen, setActiveKey = _b.setActiveKey;
  var _c = (0, import_react.useState)(Boolean(_activeItemKey === _itemKey.current)), visible = _c[0], setVisible = _c[1];
  (0, import_react.useEffect)(function() {
    !alwaysOpen && visible && setActiveKey(_itemKey.current);
  }, [visible]);
  (0, import_react.useEffect)(function() {
    setVisible(Boolean(_activeItemKey === _itemKey.current));
  }, [_activeItemKey]);
  var _className = classNames("accordion-item", className);
  return import_react.default.createElement(
    "div",
    __assign({ className: _className }, rest, { ref }),
    import_react.default.createElement(CAccordionItemContext.Provider, { value: { setVisible, visible } }, children2)
  );
});
CAccordionItem.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  itemKey: propTypes.exports.oneOfType([propTypes.exports.number, propTypes.exports.string])
};
CAccordionItem.displayName = "CAccordionItem";
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function hasClass(element, className) {
  if (element.classList)
    return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList)
    element.classList.add(className);
  else if (!hasClass(element, className))
    if (typeof element.className === "string")
      element.className = element.className + " " + className;
    else
      element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
var config = {
  disabled: false
};
var timeoutsShape = true ? propTypes.exports.oneOfType([propTypes.exports.number, propTypes.exports.shape({
  enter: propTypes.exports.number,
  exit: propTypes.exports.number,
  appear: propTypes.exports.number
}).isRequired]) : null;
var classNamesShape = true ? propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.shape({
  enter: propTypes.exports.string,
  exit: propTypes.exports.string,
  active: propTypes.exports.string
}), propTypes.exports.shape({
  enter: propTypes.exports.string,
  enterDone: propTypes.exports.string,
  enterActive: propTypes.exports.string,
  exit: propTypes.exports.string,
  exitDone: propTypes.exports.string,
  exitActive: propTypes.exports.string
})]) : null;
var TransitionGroupContext = import_react.default.createContext(null);
var forceReflow = function forceReflow2(node) {
  return node.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
          if (node)
            forceReflow(node);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : import_react_dom.default.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children2 = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return import_react.default.createElement(TransitionGroupContext.Provider, {
      value: null
    }, typeof children2 === "function" ? children2(status, childProps) : import_react.default.cloneElement(import_react.default.Children.only(children2), childProps));
  };
  return Transition2;
}(import_react.default.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = true ? {
  nodeRef: propTypes.exports.shape({
    current: typeof Element === "undefined" ? propTypes.exports.any : function(propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return propTypes.exports.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),
  children: propTypes.exports.oneOfType([propTypes.exports.func.isRequired, propTypes.exports.element.isRequired]).isRequired,
  in: propTypes.exports.bool,
  mountOnEnter: propTypes.exports.bool,
  unmountOnExit: propTypes.exports.bool,
  appear: propTypes.exports.bool,
  enter: propTypes.exports.bool,
  exit: propTypes.exports.bool,
  timeout: function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener)
      pt = pt.isRequired;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return pt.apply(void 0, [props].concat(args));
  },
  addEndListener: propTypes.exports.func,
  onEnter: propTypes.exports.func,
  onEntering: propTypes.exports.func,
  onEntered: propTypes.exports.func,
  onExit: propTypes.exports.func,
  onExiting: propTypes.exports.func,
  onExited: propTypes.exports.func
} : {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return addClass(node, c);
  });
};
var removeClass = function removeClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return removeClass$1(node, c);
  });
};
var CSSTransition = function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames2 = _this.props.classNames;
      var isStringClassNames = typeof classNames2 === "string";
      var prefix = isStringClassNames && classNames2 ? classNames2 + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames2[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames2[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames2[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node)
        forceReflow(node);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node, baseClassName);
    }
    if (activeClassName) {
      removeClass(node, activeClassName);
    }
    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return import_react.default.createElement(Transition, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(import_react.default.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = true ? _extends({}, Transition.propTypes, {
  classNames: classNamesShape,
  onEnter: propTypes.exports.func,
  onEntering: propTypes.exports.func,
  onEntered: propTypes.exports.func,
  onExit: propTypes.exports.func,
  onExiting: propTypes.exports.func,
  onExited: propTypes.exports.func
}) : {};
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function getChildMapping(children2, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && (0, import_react.isValidElement)(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children2)
    import_react.Children.map(children2, function(c) {
      return c;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return (0, import_react.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children2 = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children2).forEach(function(key) {
    var child = children2[key];
    if (!(0, import_react.isValidElement)(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = (0, import_react.isValidElement)(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children2[key] = (0, import_react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children2[key] = (0, import_react.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0, import_react.isValidElement)(prevChild)) {
      children2[key] = (0, import_react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children2;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k) {
    return obj[k];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children2 = _extends({}, state.children);
        delete children2[child.key];
        return {
          children: children2
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children2 = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return import_react.default.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children2);
    }
    return import_react.default.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, import_react.default.createElement(Component, props, children2));
  };
  return TransitionGroup2;
}(import_react.default.Component);
TransitionGroup.propTypes = true ? {
  component: propTypes.exports.any,
  children: propTypes.exports.node,
  appear: propTypes.exports.bool,
  enter: propTypes.exports.bool,
  exit: propTypes.exports.bool,
  childFactory: propTypes.exports.func
} : {};
TransitionGroup.defaultProps = defaultProps;
var ReplaceTransition = function(_React$Component) {
  _inheritsLoose(ReplaceTransition2, _React$Component);
  function ReplaceTransition2() {
    var _this;
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.handleEnter = function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.handleLifecycle("onEnter", 0, args);
    };
    _this.handleEntering = function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.handleLifecycle("onEntering", 0, args);
    };
    _this.handleEntered = function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.handleLifecycle("onEntered", 0, args);
    };
    _this.handleExit = function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.handleLifecycle("onExit", 1, args);
    };
    _this.handleExiting = function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.handleLifecycle("onExiting", 1, args);
    };
    _this.handleExited = function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _this.handleLifecycle("onExited", 1, args);
    };
    return _this;
  }
  var _proto = ReplaceTransition2.prototype;
  _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;
    var children2 = this.props.children;
    var child = import_react.default.Children.toArray(children2)[idx];
    if (child.props[handler])
      (_child$props = child.props)[handler].apply(_child$props, originalArgs);
    if (this.props[handler]) {
      var maybeNode = child.props.nodeRef ? void 0 : import_react_dom.default.findDOMNode(this);
      this.props[handler](maybeNode);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, children2 = _this$props.children, inProp = _this$props.in, props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);
    var _React$Children$toArr = import_react.default.Children.toArray(children2), first = _React$Children$toArr[0], second = _React$Children$toArr[1];
    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return import_react.default.createElement(TransitionGroup, props, inProp ? import_react.default.cloneElement(first, {
      key: "first",
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : import_react.default.cloneElement(second, {
      key: "second",
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  };
  return ReplaceTransition2;
}(import_react.default.Component);
ReplaceTransition.propTypes = true ? {
  in: propTypes.exports.bool.isRequired,
  children: function children(props, propName) {
    if (import_react.default.Children.count(props[propName]) !== 2)
      return new Error('"' + propName + '" must be exactly two transition components.');
    return null;
  }
} : {};
var _leaveRenders;
var _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren)
    return false;
  if (import_react.default.isValidElement(oldChildren) && import_react.default.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }
  return true;
}
var modes = {
  out: "out-in",
  in: "in-out"
};
var callHook = function callHook2(element, name, cb) {
  return function() {
    var _element$props;
    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
    cb();
  };
};
var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(_ref) {
  var current = _ref.current, changeState = _ref.changeState;
  return import_react.default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(_ref2) {
  var current = _ref2.current, changeState = _ref2.changeState, children2 = _ref2.children;
  return [current, import_react.default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERING);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(_ref3) {
  var children2 = _ref3.children, changeState = _ref3.changeState;
  return import_react.default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERED, import_react.default.cloneElement(children2, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function(_ref4) {
  var current = _ref4.current, children2 = _ref4.children, changeState = _ref4.changeState;
  return [import_react.default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERED, import_react.default.cloneElement(children2, {
        in: true
      }));
    })
  }), import_react.default.cloneElement(children2, {
    in: true
  })];
}, _enterRenders);
var SwitchTransition = function(_React$Component) {
  _inheritsLoose(SwitchTransition2, _React$Component);
  function SwitchTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: ENTERED,
      current: null
    };
    _this.appeared = false;
    _this.changeState = function(status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }
      _this.setState({
        status,
        current
      });
    };
    return _this;
  }
  var _proto = SwitchTransition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };
  SwitchTransition2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }
    if (state.status === ENTERING && props.mode === modes.in) {
      return {
        status: ENTERING
      };
    }
    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: EXITING
      };
    }
    return {
      current: import_react.default.cloneElement(props.children, {
        in: true
      })
    };
  };
  _proto.render = function render() {
    var _this$props = this.props, children2 = _this$props.children, mode = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
    var data = {
      children: children2,
      current,
      changeState: this.changeState,
      status
    };
    var component;
    switch (status) {
      case ENTERING:
        component = enterRenders[mode](data);
        break;
      case EXITING:
        component = leaveRenders[mode](data);
        break;
      case ENTERED:
        component = current;
    }
    return import_react.default.createElement(TransitionGroupContext.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };
  return SwitchTransition2;
}(import_react.default.Component);
SwitchTransition.propTypes = true ? {
  mode: propTypes.exports.oneOf([modes.in, modes.out]),
  children: propTypes.exports.oneOfType([propTypes.exports.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};
function useForkedRef() {
  var refs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    refs[_i] = arguments[_i];
  }
  return (0, import_react.useMemo)(function() {
    if (refs.every(function(ref) {
      return ref == null;
    })) {
      return null;
    }
    return function(node) {
      refs.forEach(function(ref) {
        assignRef(ref, node);
      });
    };
  }, refs);
}
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (isFunction(ref)) {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error('Cannot assign value "'.concat(value, '" to ref "').concat(ref, '"'));
    }
  }
}
function isFunction(value) {
  return !!(value && {}.toString.call(value) == "[object Function]");
}
var CCollapse = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, horizontal = _a.horizontal, onHide = _a.onHide, onShow = _a.onShow, visible = _a.visible, rest = __rest(_a, ["children", "className", "horizontal", "onHide", "onShow", "visible"]);
  var _b = (0, import_react.useState)(), height = _b[0], setHeight = _b[1];
  var _c = (0, import_react.useState)(), width = _c[0], setWidth = _c[1];
  var collapseRef = (0, import_react.useRef)(null);
  var forkedRef = useForkedRef(ref, collapseRef);
  var getTransitionClass = function(state) {
    return state === "entering" ? "collapsing" : state === "entered" ? "collapse show" : state === "exiting" ? "collapsing" : "collapse";
  };
  var onEntering = function() {
    onShow && onShow();
    if (horizontal) {
      collapseRef.current && setWidth(collapseRef.current.scrollWidth);
      return;
    }
    collapseRef.current && setHeight(collapseRef.current.scrollHeight);
  };
  var onEntered = function() {
    if (horizontal) {
      setWidth(0);
      return;
    }
    setHeight(0);
  };
  var onExit = function() {
    if (horizontal) {
      collapseRef.current && setWidth(collapseRef.current.scrollWidth);
      return;
    }
    collapseRef.current && setHeight(collapseRef.current.scrollHeight);
  };
  var onExiting = function() {
    onHide && onHide();
    if (horizontal) {
      setWidth(0);
      return;
    }
    setHeight(0);
  };
  var onExited = function() {
    if (horizontal) {
      setWidth(0);
      return;
    }
    setHeight(0);
  };
  var _className = classNames({
    "collapse-horizontal": horizontal
  }, className);
  return import_react.default.createElement(CSSTransition, { in: visible, nodeRef: collapseRef, onEntering, onEntered, onExit, onExiting, onExited, timeout: 350 }, function(state) {
    var transitionClass = getTransitionClass(state);
    var currentHeight = height === 0 ? null : { height };
    var currentWidth = width === 0 ? null : { width };
    return import_react.default.createElement("div", __assign({ className: classNames(_className, transitionClass), style: __assign(__assign({}, currentHeight), currentWidth) }, rest, { ref: forkedRef }), children2);
  });
});
CCollapse.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  horizontal: propTypes.exports.bool,
  onHide: propTypes.exports.func,
  onShow: propTypes.exports.func,
  visible: propTypes.exports.bool
};
CCollapse.displayName = "CCollapse";
var CAccordionBody = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var visible = (0, import_react.useContext)(CAccordionItemContext).visible;
  var _className = classNames("accordion-body", className);
  return import_react.default.createElement(
    CCollapse,
    { className: "accordion-collpase", visible },
    import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2)
  );
});
CAccordionBody.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CAccordionBody.displayName = "CAccordionBody";
var CAccordionButton = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _b = (0, import_react.useContext)(CAccordionItemContext), visible = _b.visible, setVisible = _b.setVisible;
  var _className = classNames("accordion-button", { collapsed: !visible }, className);
  return import_react.default.createElement("button", __assign({ type: "button", className: _className, "aria-expanded": !visible, onClick: function() {
    return setVisible(!visible);
  } }, rest, { ref }), children2);
});
CAccordionButton.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CAccordionButton.displayName = "CAccordionButton";
var CAccordionCollapse = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, props = __rest(_a, ["children"]);
  return import_react.default.createElement(CCollapse, __assign({ className: "accordion-collapse" }, props, { ref }), children2);
});
CAccordionCollapse.propTypes = {
  children: propTypes.exports.node
};
CAccordionCollapse.displayName = "CAccordionCollapse";
var CAccordionHeader = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("accordion-header", className);
  return import_react.default.createElement(
    "div",
    __assign({ className: _className }, rest, { ref }),
    import_react.default.createElement(CAccordionButton, null, children2)
  );
});
CAccordionHeader.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CAccordionHeader.displayName = "CAccordionHeader";
var colorPropType = propTypes.exports.oneOfType([
  propTypes.exports.oneOf([
    "primary",
    "secondary",
    "success",
    "danger",
    "warning",
    "info",
    "dark",
    "light"
  ]),
  propTypes.exports.string
]);
var placementPropType = propTypes.exports.oneOf([
  "auto",
  "auto-start",
  "auto-end",
  "top-end",
  "top",
  "top-start",
  "bottom-end",
  "bottom",
  "bottom-start",
  "right-start",
  "right",
  "right-end",
  "left-start",
  "left",
  "left-end"
]);
var shapePropType = propTypes.exports.oneOfType([
  propTypes.exports.oneOf([
    "rounded",
    "rounded-top",
    "rounded-end",
    "rounded-bottom",
    "rounded-start",
    "rounded-circle",
    "rounded-pill",
    "rounded-0",
    "rounded-1",
    "rounded-2",
    "rounded-3"
  ]),
  propTypes.exports.string
]);
var textColorsPropType = propTypes.exports.oneOfType([
  colorPropType,
  propTypes.exports.oneOf(["white", "muted"]),
  propTypes.exports.string
]);
var triggerPropType = propTypes.exports.oneOf(["hover", "focus", "click"]);
var CCloseButton = (0, import_react.forwardRef)(function(_a, ref) {
  var className = _a.className, disabled = _a.disabled, white = _a.white, rest = __rest(_a, ["className", "disabled", "white"]);
  var _className = classNames("btn", "btn-close", {
    "btn-close-white": white
  }, disabled, className);
  return import_react.default.createElement("button", __assign({ type: "button", className: _className, "aria-label": "Close", disabled }, rest, { ref }));
});
CCloseButton.propTypes = {
  className: propTypes.exports.string,
  disabled: propTypes.exports.bool,
  white: propTypes.exports.bool
};
CCloseButton.displayName = "CCloseButton";
var CAlert = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, _b = _a.color, color = _b === void 0 ? "primary" : _b, dismissible = _a.dismissible, variant = _a.variant, _c = _a.visible, visible = _c === void 0 ? true : _c, onClose = _a.onClose, rest = __rest(_a, ["children", "className", "color", "dismissible", "variant", "visible", "onClose"]);
  var alertRef = (0, import_react.useRef)(null);
  var forkedRef = useForkedRef(ref, alertRef);
  var _d = (0, import_react.useState)(visible), _visible = _d[0], setVisible = _d[1];
  (0, import_react.useEffect)(function() {
    setVisible(visible);
  }, [visible]);
  var _className = classNames("alert", variant === "solid" ? "bg-".concat(color, " text-white") : "alert-".concat(color), {
    "alert-dismissible fade": dismissible
  }, className);
  var getTransitionClass = function(state) {
    return state === "entered" && "show";
  };
  return import_react.default.createElement(Transition, { in: _visible, mountOnEnter: true, nodeRef: alertRef, onExit: onClose, timeout: 150, unmountOnExit: true }, function(state) {
    var transitionClass = getTransitionClass(state);
    return import_react.default.createElement(
      "div",
      __assign({ className: classNames(_className, transitionClass), role: "alert" }, rest, { ref: forkedRef }),
      children2,
      dismissible && import_react.default.createElement(CCloseButton, { onClick: function() {
        return setVisible(false);
      } })
    );
  });
});
CAlert.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType.isRequired,
  dismissible: propTypes.exports.bool,
  onClose: propTypes.exports.func,
  variant: propTypes.exports.string,
  visible: propTypes.exports.bool
};
CAlert.displayName = "CAlert";
var CAlertHeading = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, _b = _a.component, Component = _b === void 0 ? "h4" : _b, rest = __rest(_a, ["children", "className", "component"]);
  var _className = classNames("alert-heading", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CAlertHeading.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CAlertHeading.displayName = "CAlertHeading";
var CLink = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, active = _a.active, className = _a.className, _b = _a.component, Component = _b === void 0 ? "a" : _b, disabled = _a.disabled, rest = __rest(_a, ["children", "active", "className", "component", "disabled"]);
  var _className = classNames(className, { active, disabled });
  return import_react.default.createElement(Component, __assign({ className: _className }, active && { "aria-current": "page" }, Component === "a" && disabled && { "aria-disabled": true, tabIndex: -1 }, (Component === "a" || Component === "button") && {
    onClick: function(event) {
      event.preventDefault;
      !disabled && rest.onClick && rest.onClick(event);
    }
  }, { disabled }, rest, { ref }), children2);
});
CLink.propTypes = {
  active: propTypes.exports.bool,
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType,
  disabled: propTypes.exports.bool
};
CLink.displayName = "CLink";
var CAlertLink = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("alert-link", className);
  return import_react.default.createElement(CLink, __assign({ className: _className }, rest, { ref }), children2);
});
CAlertLink.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CAlertLink.displayName = "CAlertLink";
var CAvatar = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, color = _a.color, shape = _a.shape, size = _a.size, src = _a.src, status = _a.status, textColor = _a.textColor, rest = __rest(_a, ["children", "className", "color", "shape", "size", "src", "status", "textColor"]);
  var _className = classNames("avatar", (_b = {}, _b["bg-".concat(color)] = color, _b["avatar-".concat(size)] = size, _b["text-".concat(textColor)] = textColor, _b), shape, className);
  var statusClassName = status && classNames("avatar-status", "bg-".concat(status));
  return import_react.default.createElement(
    "div",
    __assign({ className: _className }, rest, { ref }),
    src ? import_react.default.createElement("img", { src, className: "avatar-img" }) : children2,
    status && import_react.default.createElement("span", { className: statusClassName })
  );
});
CAvatar.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType,
  shape: shapePropType,
  size: propTypes.exports.string,
  src: propTypes.exports.string,
  status: propTypes.exports.string,
  textColor: textColorsPropType
};
CAvatar.displayName = "CAvatar";
var CBackdrop = (0, import_react.forwardRef)(function(_a, ref) {
  var _b = _a.className, className = _b === void 0 ? "modal-backdrop" : _b, visible = _a.visible, rest = __rest(_a, ["className", "visible"]);
  var backdropRef = (0, import_react.useRef)(null);
  var forkedRef = useForkedRef(ref, backdropRef);
  var _className = classNames(className, "fade");
  var getTransitionClass = function(state) {
    return state === "entered" && "show";
  };
  return import_react.default.createElement(Transition, { in: visible, mountOnEnter: true, nodeRef: backdropRef, timeout: 150, unmountOnExit: true }, function(state) {
    var transitionClass = getTransitionClass(state);
    return import_react.default.createElement("div", __assign({ className: classNames(_className, transitionClass) }, rest, { ref: forkedRef }));
  });
});
CBackdrop.propTypes = {
  className: propTypes.exports.string,
  visible: propTypes.exports.bool
};
CBackdrop.displayName = "CBackdrop";
var CBadge = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, color = _a.color, _c = _a.component, Component = _c === void 0 ? "span" : _c, position = _a.position, shape = _a.shape, size = _a.size, textColor = _a.textColor, rest = __rest(_a, ["children", "className", "color", "component", "position", "shape", "size", "textColor"]);
  var _className = classNames("badge", (_b = {}, _b["bg-".concat(color)] = color, _b["position-absolute translate-middle"] = position, _b["top-0"] = position === null || position === void 0 ? void 0 : position.includes("top"), _b["top-100"] = position === null || position === void 0 ? void 0 : position.includes("bottom"), _b["start-100"] = position === null || position === void 0 ? void 0 : position.includes("end"), _b["start-0"] = position === null || position === void 0 ? void 0 : position.includes("start"), _b["badge-".concat(size)] = size, _b["text-".concat(textColor)] = textColor, _b), shape, className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CBadge.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType,
  component: propTypes.exports.string,
  position: propTypes.exports.oneOf(["top-start", "top-end", "bottom-end", "bottom-start"]),
  shape: shapePropType,
  size: propTypes.exports.oneOf(["sm"]),
  textColor: textColorsPropType
};
CBadge.displayName = "CBadge";
var CBreadcrumb = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("breadcrumb", className);
  return import_react.default.createElement(
    "nav",
    { "aria-label": "breadcrumb" },
    import_react.default.createElement("ol", __assign({ className: _className }, rest, { ref }), children2)
  );
});
CBreadcrumb.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CBreadcrumb.displayName = "CBreadcrumb";
var CBreadcrumbItem = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, active = _a.active, className = _a.className, href = _a.href, rest = __rest(_a, ["children", "active", "className", "href"]);
  var _className = classNames("breadcrumb-item", {
    active
  }, className);
  return import_react.default.createElement("li", __assign({ className: _className }, active && { "aria-current": "page" }, rest, { ref }), href ? import_react.default.createElement(CLink, { href }, children2) : children2);
});
CBreadcrumbItem.propTypes = {
  active: propTypes.exports.bool,
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  href: propTypes.exports.string
};
CBreadcrumbItem.displayName = "CBreadcrumbItem";
var CButton = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, _c = _a.color, color = _c === void 0 ? "primary" : _c, _d = _a.component, component = _d === void 0 ? "button" : _d, shape = _a.shape, size = _a.size, _e = _a.type, type = _e === void 0 ? "button" : _e, variant = _a.variant, rest = __rest(_a, ["children", "className", "color", "component", "shape", "size", "type", "variant"]);
  var _className = classNames("btn", variant ? "btn-".concat(variant, "-").concat(color) : "btn-".concat(color), (_b = {}, _b["btn-".concat(size)] = size, _b), shape, className);
  return import_react.default.createElement(CLink, __assign({ component: rest.href ? "a" : component, type, className: _className }, rest, { ref }), children2);
});
CButton.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType,
  component: propTypes.exports.elementType,
  shape: propTypes.exports.string,
  size: propTypes.exports.oneOf(["sm", "lg"]),
  type: propTypes.exports.oneOf(["button", "submit", "reset"]),
  variant: propTypes.exports.oneOf(["outline", "ghost"])
};
CButton.displayName = "CButton";
var CButtonToolbar = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("btn-toolbar", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CButtonToolbar.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CButtonToolbar.displayName = "CButtonToolbar";
var CButtonGroup = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, size = _a.size, vertical = _a.vertical, rest = __rest(_a, ["children", "className", "size", "vertical"]);
  var _className = classNames(vertical ? "btn-group-vertical" : "btn-group", (_b = {}, _b["btn-group-".concat(size)] = size, _b), className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CButtonGroup.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  size: propTypes.exports.oneOf(["sm", "lg"]),
  vertical: propTypes.exports.bool
};
CButtonGroup.displayName = "CButtonGroup";
var CCallout = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, color = _a.color, rest = __rest(_a, ["children", "className", "color"]);
  var _className = classNames("callout", (_b = {}, _b["callout-".concat(color)] = color, _b), className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CCallout.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType
};
CCallout.displayName = "CCallout";
var CCard = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, color = _a.color, textColor = _a.textColor, rest = __rest(_a, ["children", "className", "color", "textColor"]);
  var _className = classNames("card", (_b = {}, _b["bg-".concat(color)] = color, _b["text-".concat(textColor)] = textColor, _b), className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CCard.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType,
  textColor: propTypes.exports.string
};
CCard.displayName = "CCard";
var CCardBody = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("card-body", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CCardBody.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CCardBody.displayName = "CCardBody";
var CCardFooter = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("card-footer", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CCardFooter.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CCardFooter.displayName = "CCardFooter";
var CCardGroup = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("card-group", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CCardGroup.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CCardGroup.displayName = "CCardGroup";
var CCardHeader = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, _b = _a.component, Component = _b === void 0 ? "div" : _b, className = _a.className, rest = __rest(_a, ["children", "component", "className"]);
  var _className = classNames("card-header", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CCardHeader.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CCardHeader.displayName = "CCardHeader";
var CCardImage = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, _b = _a.component, Component = _b === void 0 ? "img" : _b, orientation = _a.orientation, rest = __rest(_a, ["children", "className", "component", "orientation"]);
  var _className = classNames(orientation ? "card-img-".concat(orientation) : "card-img", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CCardImage.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType,
  orientation: propTypes.exports.oneOf(["top", "bottom"])
};
CCardImage.displayName = "CCardImage";
var CCardImageOverlay = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("card-img-overlay", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CCardImageOverlay.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CCardImageOverlay.displayName = "CCardImageOverlay";
var CCardLink = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("card-link", className);
  return import_react.default.createElement(CLink, __assign({ className: _className }, rest, { ref }), children2);
});
CCardLink.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CCardLink.displayName = "CCardLink";
var CCardSubtitle = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, _b = _a.component, Component = _b === void 0 ? "h6" : _b, className = _a.className, rest = __rest(_a, ["children", "component", "className"]);
  var _className = classNames("card-subtitle", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CCardSubtitle.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CCardSubtitle.displayName = "CCardSubtitle";
var CCardText = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, _b = _a.component, Component = _b === void 0 ? "p" : _b, className = _a.className, rest = __rest(_a, ["children", "component", "className"]);
  var _className = classNames("card-text", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CCardText.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CCardText.displayName = "CCardText";
var CCardTitle = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, _b = _a.component, Component = _b === void 0 ? "h5" : _b, className = _a.className, rest = __rest(_a, ["children", "component", "className"]);
  var _className = classNames("card-title", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CCardTitle.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CCardTitle.displayName = "CCardTitle";
var isVisible$1 = function(element) {
  var rect = element.getBoundingClientRect();
  return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
};
var CCarouselContext = (0, import_react.createContext)({});
var CCarousel = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, _b = _a.activeIndex, activeIndex = _b === void 0 ? 0 : _b, className = _a.className, controls = _a.controls, dark = _a.dark, indicators = _a.indicators, _c = _a.interval, interval = _c === void 0 ? 5e3 : _c, onSlid = _a.onSlid, onSlide = _a.onSlide, _d = _a.pause, pause = _d === void 0 ? "hover" : _d, transition = _a.transition, _e = _a.wrap, wrap = _e === void 0 ? true : _e, rest = __rest(_a, ["children", "activeIndex", "className", "controls", "dark", "indicators", "interval", "onSlid", "onSlide", "pause", "transition", "wrap"]);
  var carouselRef = (0, import_react.useRef)(null);
  var forkedRef = useForkedRef(ref, carouselRef);
  var data = (0, import_react.useRef)({}).current;
  var _f = (0, import_react.useState)(activeIndex), active = _f[0], setActive = _f[1];
  var _g = (0, import_react.useState)(false), animating = _g[0], setAnimating = _g[1];
  var _h = (0, import_react.useState)(), customInterval = _h[0], setCustomInterval = _h[1];
  var _j = (0, import_react.useState)("next"), direction = _j[0], setDirection = _j[1];
  var _k = (0, import_react.useState)(0), itemsNumber = _k[0], setItemsNumber = _k[1];
  var _l = (0, import_react.useState)(), visible = _l[0], setVisible = _l[1];
  (0, import_react.useEffect)(function() {
    setItemsNumber(import_react.Children.toArray(children2).length);
  });
  (0, import_react.useEffect)(function() {
    visible && cycle();
  }, [visible]);
  (0, import_react.useEffect)(function() {
    !animating && cycle();
    !animating && onSlid && onSlid(active, direction);
    animating && onSlide && onSlide(active, direction);
  }, [animating]);
  (0, import_react.useEffect)(function() {
    window.addEventListener("scroll", handleScroll);
    return function() {
      window.removeEventListener("scroll", handleScroll);
    };
  });
  var _className = classNames("carousel slide", transition === "crossfade" && "carousel-fade", dark && "carousel-dark", className);
  var cycle = function() {
    _pause();
    if (!wrap && active === itemsNumber - 1) {
      return;
    }
    if (typeof interval === "number") {
      data.timeout = setTimeout(function() {
        return nextItemWhenVisible();
      }, typeof customInterval === "number" ? customInterval : interval);
    }
  };
  var _pause = function() {
    return pause && data.timeout && clearTimeout(data.timeout);
  };
  var nextItemWhenVisible = function() {
    if (!document.hidden && carouselRef.current && isVisible$1(carouselRef.current)) {
      if (animating) {
        return;
      }
      handleControlClick("next");
    }
  };
  var handleControlClick = function(direction2) {
    if (animating) {
      return;
    }
    setDirection(direction2);
    if (direction2 === "next") {
      active === itemsNumber - 1 ? setActive(0) : setActive(active + 1);
    } else {
      active === 0 ? setActive(itemsNumber - 1) : setActive(active - 1);
    }
  };
  var handleIndicatorClick = function(index) {
    if (active === index) {
      return;
    }
    if (active < index) {
      setDirection("next");
      setActive(index);
      return;
    }
    if (active > index) {
      setDirection("prev");
      setActive(index);
    }
  };
  var handleScroll = function() {
    if (!document.hidden && carouselRef.current && isVisible$1(carouselRef.current)) {
      setVisible(true);
    } else {
      setVisible(false);
    }
  };
  return import_react.default.createElement(
    "div",
    __assign({ className: _className, onMouseEnter: _pause, onMouseLeave: cycle }, rest, { ref: forkedRef }),
    import_react.default.createElement(
      CCarouselContext.Provider,
      { value: {
        setAnimating,
        setCustomInterval
      } },
      indicators && import_react.default.createElement("ol", { className: "carousel-indicators" }, Array.from({ length: itemsNumber }, function(_, i) {
        return i;
      }).map(function(index) {
        return import_react.default.createElement("li", { key: "indicator".concat(index), onClick: function() {
          !animating && handleIndicatorClick(index);
        }, className: active === index ? "active" : "", "data-coreui-target": "" });
      })),
      import_react.default.createElement("div", { className: "carousel-inner" }, import_react.Children.map(children2, function(child, index) {
        if (import_react.default.isValidElement(child)) {
          return import_react.default.cloneElement(child, {
            active: active === index ? true : false,
            direction,
            key: index
          });
        }
        return;
      })),
      controls && import_react.default.createElement(
        import_react.default.Fragment,
        null,
        import_react.default.createElement(
          "button",
          { className: "carousel-control-prev", onClick: function() {
            return handleControlClick("prev");
          } },
          import_react.default.createElement("span", { className: "carousel-control-prev-icon", "aria-label": "prev" })
        ),
        import_react.default.createElement(
          "button",
          { className: "carousel-control-next", onClick: function() {
            return handleControlClick("next");
          } },
          import_react.default.createElement("span", { className: "carousel-control-next-icon", "aria-label": "next" })
        )
      )
    )
  );
});
CCarousel.propTypes = {
  activeIndex: propTypes.exports.number,
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  controls: propTypes.exports.bool,
  dark: propTypes.exports.bool,
  indicators: propTypes.exports.bool,
  interval: propTypes.exports.oneOfType([propTypes.exports.bool, propTypes.exports.number]),
  onSlid: propTypes.exports.func,
  onSlide: propTypes.exports.func,
  pause: propTypes.exports.oneOf([false, "hover"]),
  transition: propTypes.exports.oneOf(["slide", "crossfade"]),
  wrap: propTypes.exports.bool
};
CCarousel.displayName = "CCarousel";
var CCarouselCaption = (0, import_react.forwardRef)(function(_a, ref) {
  var className = _a.className, rest = __rest(_a, ["className"]);
  var _className = classNames("carousel-caption", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }));
});
CCarouselCaption.propTypes = {
  className: propTypes.exports.string
};
CCarouselCaption.displayName = "CCarouselCaption";
var CCarouselItem = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, active = _a.active, direction = _a.direction, _b = _a.interval, interval = _b === void 0 ? false : _b, rest = __rest(_a, ["children", "className", "active", "direction", "interval"]);
  var _c = (0, import_react.useContext)(CCarouselContext), setAnimating = _c.setAnimating, setCustomInterval = _c.setCustomInterval;
  var carouselItemRef = (0, import_react.useRef)(null);
  var forkedRef = useForkedRef(ref, carouselItemRef);
  var prevActive = (0, import_react.useRef)();
  var _d = (0, import_react.useState)(), directionClassName = _d[0], setDirectionClassName = _d[1];
  var _e = (0, import_react.useState)(), orderClassName = _e[0], setOrderClassName = _e[1];
  var _f = (0, import_react.useState)(active && "active"), activeClassName = _f[0], setActiveClassName = _f[1];
  var _g = (0, import_react.useState)(0), count = _g[0], setCount = _g[1];
  (0, import_react.useEffect)(function() {
    if (active) {
      setCustomInterval(interval);
      if (count !== 0)
        setOrderClassName("carousel-item-".concat(direction));
    }
    if (prevActive.current && !active) {
      setActiveClassName("active");
    }
    if (active || prevActive.current) {
      setTimeout(function() {
        var _a2;
        if (count !== 0) {
          (_a2 = carouselItemRef.current) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight;
          setDirectionClassName("carousel-item-".concat(direction === "next" ? "start" : "end"));
        }
      }, 0);
    }
    prevActive.current = active;
    if (count === 0)
      setCount(count + 1);
  }, [active]);
  (0, import_react.useEffect)(function() {
    var _a2, _b2;
    (_a2 = carouselItemRef.current) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("transitionstart", function() {
      active && setAnimating(true);
    });
    (_b2 = carouselItemRef.current) === null || _b2 === void 0 ? void 0 : _b2.addEventListener("transitionend", function() {
      active && setAnimating(false);
      setDirectionClassName("");
      setOrderClassName("");
      if (active) {
        setActiveClassName("active");
      }
      if (!active) {
        setActiveClassName("");
      }
    });
    return function() {
      var _a3, _b3;
      (_a3 = carouselItemRef.current) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener("transitionstart", function() {
        active && setAnimating(true);
      });
      (_b3 = carouselItemRef.current) === null || _b3 === void 0 ? void 0 : _b3.removeEventListener("transitionend", function() {
        active && setAnimating(false);
        setDirectionClassName("");
        setOrderClassName("");
        if (active) {
          setActiveClassName("active");
        }
        if (!active) {
          setActiveClassName("");
        }
      });
    };
  });
  var _className = classNames("carousel-item", activeClassName, directionClassName, orderClassName, className);
  return import_react.default.createElement("div", __assign({ className: _className, ref: forkedRef }, rest), children2);
});
CCarouselItem.propTypes = {
  active: propTypes.exports.bool,
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  direction: propTypes.exports.string,
  interval: propTypes.exports.oneOfType([propTypes.exports.bool, propTypes.exports.number])
};
CCarouselItem.displayName = "CCarouselItem";
var ManagerReferenceNodeContext = React.createContext();
var ManagerReferenceNodeSetterContext = React.createContext();
function Manager(_ref) {
  var children2 = _ref.children;
  var _React$useState = React.useState(null), referenceNode = _React$useState[0], setReferenceNode = _React$useState[1];
  var hasUnmounted = React.useRef(false);
  React.useEffect(function() {
    return function() {
      hasUnmounted.current = true;
    };
  }, []);
  var handleSetReferenceNode = React.useCallback(function(node) {
    if (!hasUnmounted.current) {
      setReferenceNode(node);
    }
  }, []);
  return React.createElement(ManagerReferenceNodeContext.Provider, {
    value: referenceNode
  }, React.createElement(ManagerReferenceNodeSetterContext.Provider, {
    value: handleSetReferenceNode
  }, children2));
}
var unwrapArray = function unwrapArray2(arg) {
  return Array.isArray(arg) ? arg[0] : arg;
};
var safeInvoke = function safeInvoke2(fn2) {
  if (typeof fn2 === "function") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return fn2.apply(void 0, args);
  }
};
var setRef = function setRef2(ref, node) {
  if (typeof ref === "function") {
    return safeInvoke(ref, node);
  } else if (ref != null) {
    ref.current = node;
  }
};
var fromEntries = function fromEntries2(entries) {
  return entries.reduce(function(acc, _ref) {
    var key = _ref[0], value = _ref[1];
    acc[key] = value;
    return acc;
  }, {});
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? React.useLayoutEffect : React.useEffect;
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle$1(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = popperGenerator({
  defaultModifiers
});
var hasElementType = typeof Element !== "undefined";
var hasMap = typeof Map === "function";
var hasSet = typeof Set === "function";
var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    var it;
    if (hasMap && a instanceof Map && b instanceof Map) {
      if (a.size !== b.size)
        return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0]))
          return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!equal(i.value[1], b.get(i.value[0])))
          return false;
      return true;
    }
    if (hasSet && a instanceof Set && b instanceof Set) {
      if (a.size !== b.size)
        return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0]))
          return false;
      return true;
    }
    if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (a[i] !== b[i])
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    if (hasElementType && a instanceof Element)
      return false;
    for (i = length; i-- !== 0; ) {
      if ((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) {
        continue;
      }
      if (!equal(a[keys[i]], b[keys[i]]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}
var reactFastCompare = function isEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if ((error.message || "").match(/stack|recursion/i)) {
      console.warn("react-fast-compare cannot handle circular refs");
      return false;
    }
    throw error;
  }
};
var EMPTY_MODIFIERS$1 = [];
var usePopper = function usePopper2(referenceElement, popperElement, options) {
  if (options === void 0) {
    options = {};
  }
  var prevOptions = React.useRef(null);
  var optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS$1
  };
  var _React$useState = React.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), state = _React$useState[0], setState = _React$useState[1];
  var updateStateModifier = React.useMemo(function() {
    return {
      name: "updateState",
      enabled: true,
      phase: "write",
      fn: function fn2(_ref) {
        var state2 = _ref.state;
        var elements = Object.keys(state2.elements);
        ReactDOM.flushSync(function() {
          setState({
            styles: fromEntries(elements.map(function(element) {
              return [element, state2.styles[element] || {}];
            })),
            attributes: fromEntries(elements.map(function(element) {
              return [element, state2.attributes[element]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []);
  var popperOptions = React.useMemo(function() {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
        name: "applyStyles",
        enabled: false
      }])
    };
    if (reactFastCompare(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = React.useRef();
  useIsomorphicLayoutEffect(function() {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(function() {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    var createPopper$1 = options.createPopper || createPopper;
    var popperInstance = createPopper$1(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return function() {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};
var NOOP = function NOOP2() {
  return void 0;
};
var NOOP_PROMISE = function NOOP_PROMISE2() {
  return Promise.resolve(null);
};
var EMPTY_MODIFIERS = [];
function Popper(_ref) {
  var _ref$placement = _ref.placement, placement = _ref$placement === void 0 ? "bottom" : _ref$placement, _ref$strategy = _ref.strategy, strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy, _ref$modifiers = _ref.modifiers, modifiers = _ref$modifiers === void 0 ? EMPTY_MODIFIERS : _ref$modifiers, referenceElement = _ref.referenceElement, onFirstUpdate = _ref.onFirstUpdate, innerRef = _ref.innerRef, children2 = _ref.children;
  var referenceNode = React.useContext(ManagerReferenceNodeContext);
  var _React$useState = React.useState(null), popperElement = _React$useState[0], setPopperElement = _React$useState[1];
  var _React$useState2 = React.useState(null), arrowElement = _React$useState2[0], setArrowElement = _React$useState2[1];
  React.useEffect(function() {
    setRef(innerRef, popperElement);
  }, [innerRef, popperElement]);
  var options = React.useMemo(function() {
    return {
      placement,
      strategy,
      onFirstUpdate,
      modifiers: [].concat(modifiers, [{
        name: "arrow",
        enabled: arrowElement != null,
        options: {
          element: arrowElement
        }
      }])
    };
  }, [placement, strategy, onFirstUpdate, modifiers, arrowElement]);
  var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options), state = _usePopper.state, styles = _usePopper.styles, forceUpdate = _usePopper.forceUpdate, update = _usePopper.update;
  var childrenProps = React.useMemo(function() {
    return {
      ref: setPopperElement,
      style: styles.popper,
      placement: state ? state.placement : placement,
      hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: styles.arrow,
        ref: setArrowElement
      },
      forceUpdate: forceUpdate || NOOP,
      update: update || NOOP_PROMISE
    };
  }, [setPopperElement, setArrowElement, placement, state, styles, update, forceUpdate]);
  return unwrapArray(children2)(childrenProps);
}
var __DEV__ = true;
var warning = function() {
};
if (__DEV__) {
  printWarning = function printWarning2(format2, args) {
    var len = arguments.length;
    args = new Array(len > 1 ? len - 1 : 0);
    for (var key = 1; key < len; key++) {
      args[key - 1] = arguments[key];
    }
    var argIndex = 0;
    var message = "Warning: " + format2.replace(/%s/g, function() {
      return args[argIndex++];
    });
    if (typeof console !== "undefined") {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (x) {
    }
  };
  warning = function(condition, format2, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format2 === void 0) {
      throw new Error(
        "`warning(condition, format, ...args)` requires a warning message argument"
      );
    }
    if (!condition) {
      printWarning.apply(null, [format2].concat(args));
    }
  };
}
var printWarning;
var warning_1 = warning;
function Reference(_ref) {
  var children2 = _ref.children, innerRef = _ref.innerRef;
  var setReferenceNode = React.useContext(ManagerReferenceNodeSetterContext);
  var refHandler = React.useCallback(function(node) {
    setRef(innerRef, node);
    safeInvoke(setReferenceNode, node);
  }, [innerRef, setReferenceNode]);
  React.useEffect(function() {
    return function() {
      return setRef(innerRef, null);
    };
  }, []);
  React.useEffect(function() {
    warning_1(Boolean(setReferenceNode), "`Reference` should not be used outside of a `Manager` component.");
  }, [setReferenceNode]);
  return unwrapArray(children2)({
    ref: refHandler
  });
}
var CDropdownContext = (0, import_react.createContext)({});
var CDropdown = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, alignment = _a.alignment, _b = _a.autoClose, autoClose = _b === void 0 ? true : _b, className = _a.className, dark = _a.dark, direction = _a.direction, onHide = _a.onHide, onShow = _a.onShow, _c = _a.placement, placement = _c === void 0 ? "bottom-start" : _c, _d = _a.popper, popper2 = _d === void 0 ? true : _d, _e = _a.variant, variant = _e === void 0 ? "btn-group" : _e, _f = _a.component, component = _f === void 0 ? "div" : _f, _g = _a.visible, visible = _g === void 0 ? false : _g, rest = __rest(_a, ["children", "alignment", "autoClose", "className", "dark", "direction", "onHide", "onShow", "placement", "popper", "variant", "component", "visible"]);
  var _h = (0, import_react.useState)(visible), _visible = _h[0], setVisible = _h[1];
  var dropdownRef = (0, import_react.useRef)(null);
  var dropdownToggleRef = (0, import_react.useRef)(null);
  var forkedRef = useForkedRef(ref, dropdownRef);
  var Component = variant === "nav-item" ? "li" : component;
  if (typeof alignment === "object") {
    popper2 = false;
  }
  var contextValues = {
    alignment,
    autoClose,
    dark,
    direction,
    dropdownToggleRef,
    placement,
    popper: popper2,
    variant,
    visible: _visible,
    setVisible
  };
  var _className = classNames(variant === "nav-item" ? "nav-item dropdown" : variant, {
    show: _visible
  }, direction === "center" ? "dropdown-center" : direction === "dropup-center" ? "dropup dropup-center" : direction, className);
  (0, import_react.useEffect)(function() {
    setVisible(visible);
  }, [visible]);
  (0, import_react.useEffect)(function() {
    _visible && onShow && onShow();
    !_visible && onHide && onHide();
  }, [_visible]);
  var dropdownContent = function() {
    return variant === "input-group" ? import_react.default.createElement(import_react.default.Fragment, null, children2) : import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref: forkedRef }), children2);
  };
  return popper2 ? import_react.default.createElement(
    CDropdownContext.Provider,
    { value: contextValues },
    import_react.default.createElement(Manager, null, dropdownContent())
  ) : import_react.default.createElement(CDropdownContext.Provider, { value: contextValues }, dropdownContent());
});
var alignmentDirection = propTypes.exports.oneOf(["start", "end"]);
CDropdown.propTypes = {
  alignment: propTypes.exports.oneOfType([
    alignmentDirection,
    propTypes.exports.shape({ xs: alignmentDirection }),
    propTypes.exports.shape({ sm: alignmentDirection }),
    propTypes.exports.shape({ md: alignmentDirection }),
    propTypes.exports.shape({ lg: alignmentDirection }),
    propTypes.exports.shape({ xl: alignmentDirection }),
    propTypes.exports.shape({ xxl: alignmentDirection })
  ]),
  autoClose: propTypes.exports.oneOfType([
    propTypes.exports.bool,
    propTypes.exports.oneOf(["inside", "outside"])
  ]),
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType,
  dark: propTypes.exports.bool,
  direction: propTypes.exports.oneOf(["center", "dropup", "dropup-center", "dropend", "dropstart"]),
  onHide: propTypes.exports.func,
  onShow: propTypes.exports.func,
  placement: placementPropType,
  popper: propTypes.exports.bool,
  variant: propTypes.exports.oneOf(["btn-group", "dropdown", "input-group", "nav-item"]),
  visible: propTypes.exports.bool
};
CDropdown.displayName = "CDropdown";
var CDropdownDivider = (0, import_react.forwardRef)(function(_a, ref) {
  var className = _a.className, rest = __rest(_a, ["className"]);
  var _className = classNames("dropdown-divider", className);
  return import_react.default.createElement("hr", __assign({ className: _className }, rest, { ref }));
});
CDropdownDivider.propTypes = {
  className: propTypes.exports.string
};
CDropdownDivider.displayName = "CDropdownDivider";
var CDropdownHeader = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, _b = _a.component, Component = _b === void 0 ? "h6" : _b, rest = __rest(_a, ["children", "className", "component"]);
  var _className = classNames("dropdown-header", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CDropdownHeader.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CDropdownHeader.displayName = "CDropdownHeader";
var CDropdownItem = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, _b = _a.component, component = _b === void 0 ? "a" : _b, rest = __rest(_a, ["children", "className", "component"]);
  var _className = classNames("dropdown-item", className);
  return import_react.default.createElement(CLink, __assign({ className: _className, component }, rest, { ref }), children2);
});
CDropdownItem.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CDropdownItem.displayName = "CDropdownItem";
var CDropdownItemPlain = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, _b = _a.component, Component = _b === void 0 ? "span" : _b, rest = __rest(_a, ["children", "className", "component"]);
  var _className = classNames("dropdown-item-text", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CDropdownItemPlain.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CDropdownItemPlain.displayName = "CDropdownItemPlain";
var CDropdownMenu = function(_a) {
  var children2 = _a.children, className = _a.className, _b = _a.component, Component = _b === void 0 ? "ul" : _b, rest = __rest(_a, ["children", "className", "component"]);
  var _c = (0, import_react.useContext)(CDropdownContext), alignment = _c.alignment, autoClose = _c.autoClose, dark = _c.dark, direction = _c.direction, dropdownToggleRef = _c.dropdownToggleRef, placement = _c.placement, popper2 = _c.popper, visible = _c.visible, setVisible = _c.setVisible;
  var dropdownMenuRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(function() {
    visible && window.addEventListener("mouseup", handleMouseUp);
    visible && window.addEventListener("keyup", handleKeyup);
    return function() {
      window.removeEventListener("mouseup", handleMouseUp);
      window.removeEventListener("keyup", handleKeyup);
    };
  }, [visible]);
  var handleKeyup = function(event) {
    if (autoClose === false) {
      return;
    }
    if (event.key === "Escape") {
      setVisible(false);
    }
  };
  var handleMouseUp = function(event) {
    var _a2, _b2;
    if (dropdownToggleRef && dropdownToggleRef.current.contains(event.target)) {
      return;
    }
    if (autoClose === true || autoClose === "inside" && ((_a2 = dropdownMenuRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target)) || autoClose === "outside" && !((_b2 = dropdownMenuRef.current) === null || _b2 === void 0 ? void 0 : _b2.contains(event.target))) {
      setTimeout(function() {
        return setVisible(false);
      }, 1);
      return;
    }
  };
  var _placement = placement;
  if (direction === "center") {
    _placement = "bottom";
  }
  if (direction === "dropup") {
    _placement = "top-start";
  }
  if (direction === "dropup-center") {
    _placement = "top";
  }
  if (direction === "dropend") {
    _placement = "right-start";
  }
  if (direction === "dropstart") {
    _placement = "left-start";
  }
  if (alignment === "end") {
    _placement = "bottom-end";
  }
  var alignmentClassNames = function(alignment2) {
    var classNames2 = [];
    if (typeof alignment2 === "object") {
      Object.keys(alignment2).map(function(key) {
        classNames2.push("dropdown-menu".concat(key === "xs" ? "" : "-".concat(key), "-").concat(alignment2[key]));
      });
    }
    if (typeof alignment2 === "string") {
      classNames2.push("dropdown-menu-".concat(alignment2));
    }
    return classNames2;
  };
  var _className = classNames("dropdown-menu", {
    "dropdown-menu-dark": dark,
    show: visible
  }, alignment && alignmentClassNames(alignment), className);
  var dropdownMenuComponent = function(style, ref) {
    return import_react.default.createElement(Component, __assign({ className: _className, ref, style, role: "menu", "aria-hidden": !visible }, !popper2 && { "data-coreui-popper": "static" }, rest), Component === "ul" ? import_react.default.Children.map(children2, function(child, index) {
      if (import_react.default.isValidElement(child)) {
        return import_react.default.createElement("li", { key: index }, import_react.default.cloneElement(child));
      }
      return;
    }) : children2);
  };
  return popper2 && visible ? import_react.default.createElement(Popper, { innerRef: dropdownMenuRef, placement: _placement }, function(_a2) {
    var ref = _a2.ref, style = _a2.style;
    return dropdownMenuComponent(style, ref);
  }) : dropdownMenuComponent();
};
CDropdownMenu.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CDropdownMenu.displayName = "CDropdownMenu";
var CDropdownToggle = function(_a) {
  var children2 = _a.children, _b = _a.caret, caret = _b === void 0 ? true : _b, custom = _a.custom, className = _a.className, split = _a.split, _c = _a.trigger, trigger = _c === void 0 ? "click" : _c, rest = __rest(_a, ["children", "caret", "custom", "className", "split", "trigger"]);
  var _d = (0, import_react.useContext)(CDropdownContext), dropdownToggleRef = _d.dropdownToggleRef, popper2 = _d.popper, variant = _d.variant, visible = _d.visible, setVisible = _d.setVisible;
  var _className = classNames({
    "dropdown-toggle": caret,
    "dropdown-toggle-split": split,
    "nav-link": variant === "nav-item"
  }, className);
  var triggers = __assign(__assign({}, (trigger === "click" || trigger.includes("click")) && {
    onClick: function(event) {
      event.preventDefault();
      setVisible(!visible);
    }
  }), (trigger === "focus" || trigger.includes("focus")) && {
    onFocus: function() {
      return setVisible(true);
    },
    onBlur: function() {
      return setVisible(false);
    }
  });
  var togglerProps = __assign(__assign({ className: _className, "aria-expanded": visible }, !rest.disabled && __assign({}, triggers)), triggers);
  var Toggler = function(ref) {
    return custom && import_react.default.isValidElement(children2) ? import_react.default.createElement(import_react.default.Fragment, null, import_react.default.cloneElement(children2, __assign(__assign({ "aria-expanded": visible }, !rest.disabled && __assign({}, triggers)), { ref: useForkedRef(ref, dropdownToggleRef) }))) : variant === "nav-item" ? import_react.default.createElement("a", __assign({ href: "#" }, togglerProps, { ref: useForkedRef(ref, dropdownToggleRef) }), children2) : import_react.default.createElement(
      CButton,
      __assign({ type: "button" }, togglerProps, { tabIndex: 0 }, rest, { ref: useForkedRef(ref, dropdownToggleRef) }),
      children2,
      split && import_react.default.createElement("span", { className: "visually-hidden" }, "Toggle Dropdown")
    );
  };
  return popper2 ? import_react.default.createElement(Reference, null, function(_a2) {
    var ref = _a2.ref;
    return Toggler(ref);
  }) : Toggler(dropdownToggleRef);
};
CDropdownToggle.propTypes = {
  caret: propTypes.exports.bool,
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  custom: propTypes.exports.bool,
  split: propTypes.exports.bool,
  trigger: triggerPropType
};
CDropdownToggle.displayName = "CDropdownToggle";
var CFooter = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, position = _a.position, rest = __rest(_a, ["children", "className", "position"]);
  var _className = classNames("footer", (_b = {}, _b["footer-".concat(position)] = position, _b), className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CFooter.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  position: propTypes.exports.oneOf(["fixed", "sticky"])
};
CFooter.displayName = "CFooter";
var CForm = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, validated = _a.validated, rest = __rest(_a, ["children", "className", "validated"]);
  var _className = classNames({ "was-validated": validated }, className);
  return import_react.default.createElement("form", __assign({ className: _className }, rest, { ref }), children2);
});
CForm.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  validated: propTypes.exports.bool
};
CForm.displayName = "CForm";
var CFormFeedback = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, _c = _a.component, Component = _c === void 0 ? "div" : _c, invalid = _a.invalid, tooltip = _a.tooltip, valid = _a.valid, rest = __rest(_a, ["children", "className", "component", "invalid", "tooltip", "valid"]);
  var _className = classNames((_b = {}, _b["invalid-".concat(tooltip ? "tooltip" : "feedback")] = invalid, _b["valid-".concat(tooltip ? "tooltip" : "feedback")] = valid, _b), className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CFormFeedback.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType,
  invalid: propTypes.exports.bool,
  tooltip: propTypes.exports.bool,
  valid: propTypes.exports.bool
};
CFormFeedback.displayName = "CFormFeedback";
var CFormControlValidation = function(_a) {
  var describedby = _a.describedby, feedback = _a.feedback, feedbackInvalid = _a.feedbackInvalid, feedbackValid = _a.feedbackValid, invalid = _a.invalid, tooltipFeedback = _a.tooltipFeedback, valid = _a.valid;
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    feedback && (valid || invalid) && import_react.default.createElement(CFormFeedback, __assign({}, invalid && { id: describedby }, { invalid, tooltip: tooltipFeedback, valid }), feedback),
    feedbackInvalid && import_react.default.createElement(CFormFeedback, { id: describedby, invalid: true, tooltip: tooltipFeedback }, feedbackInvalid),
    feedbackValid && import_react.default.createElement(CFormFeedback, { valid: true, tooltip: tooltipFeedback }, feedbackValid)
  );
};
CFormControlValidation.propTypes = {
  describedby: propTypes.exports.string,
  feedback: propTypes.exports.oneOfType([propTypes.exports.node, propTypes.exports.string]),
  feedbackValid: propTypes.exports.oneOfType([propTypes.exports.node, propTypes.exports.string]),
  feedbackInvalid: propTypes.exports.oneOfType([propTypes.exports.node, propTypes.exports.string]),
  invalid: propTypes.exports.bool,
  tooltipFeedback: propTypes.exports.bool,
  valid: propTypes.exports.bool
};
CFormControlValidation.displayName = "CFormControlValidation";
var CFormLabel = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, customClassName = _a.customClassName, rest = __rest(_a, ["children", "className", "customClassName"]);
  var _className = customClassName ? customClassName : classNames("form-label", className);
  return import_react.default.createElement("label", __assign({ className: _className }, rest, { ref }), children2);
});
CFormLabel.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  customClassName: propTypes.exports.string
};
CFormLabel.displayName = "CFormLabel";
var CFormCheck = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var className = _a.className, button = _a.button, feedback = _a.feedback, feedbackInvalid = _a.feedbackInvalid, feedbackValid = _a.feedbackValid, floatingLabel = _a.floatingLabel, tooltipFeedback = _a.tooltipFeedback, hitArea = _a.hitArea, id = _a.id, indeterminate = _a.indeterminate, inline = _a.inline, invalid = _a.invalid, label = _a.label, _c = _a.type, type = _c === void 0 ? "checkbox" : _c, valid = _a.valid, rest = __rest(_a, ["className", "button", "feedback", "feedbackInvalid", "feedbackValid", "floatingLabel", "tooltipFeedback", "hitArea", "id", "indeterminate", "inline", "invalid", "label", "type", "valid"]);
  var inputRef = (0, import_react.useRef)(null);
  var forkedRef = useForkedRef(ref, inputRef);
  (0, import_react.useEffect)(function() {
    if (inputRef.current && indeterminate) {
      inputRef.current.indeterminate = indeterminate;
    }
  }, [indeterminate]);
  var _className = classNames("form-check", {
    "form-check-inline": inline,
    "is-invalid": invalid,
    "is-valid": valid
  }, className);
  var inputClassName = classNames(button ? "btn-check" : "form-check-input", {
    "is-invalid": invalid,
    "is-valid": valid,
    "me-2": hitArea
  });
  var labelClassName = classNames(button ? classNames("btn", button.variant ? "btn-".concat(button.variant, "-").concat(button.color) : "btn-".concat(button.color), (_b = {}, _b["btn-".concat(button.size)] = button.size, _b), "".concat(button.shape)) : "form-check-label");
  var formControl = function() {
    return import_react.default.createElement("input", __assign({ type, className: inputClassName, id }, rest, { ref: forkedRef }));
  };
  var formValidation = function() {
    return import_react.default.createElement(CFormControlValidation, { describedby: rest["aria-describedby"], feedback, feedbackInvalid, feedbackValid, floatingLabel, invalid, tooltipFeedback, valid });
  };
  var formLabel = function() {
    return import_react.default.createElement(CFormLabel, __assign({ customClassName: labelClassName }, id && { htmlFor: id }), label);
  };
  return button ? import_react.default.createElement(
    import_react.default.Fragment,
    null,
    formControl(),
    label && formLabel(),
    formValidation()
  ) : label ? hitArea ? import_react.default.createElement(
    import_react.default.Fragment,
    null,
    import_react.default.createElement(
      CFormLabel,
      __assign({ customClassName: className }, id && { htmlFor: id }),
      formControl(),
      label
    ),
    formValidation()
  ) : import_react.default.createElement(
    "div",
    { className: _className },
    formControl(),
    formLabel(),
    formValidation()
  ) : formControl();
});
CFormCheck.propTypes = __assign({ button: propTypes.exports.object, className: propTypes.exports.string, hitArea: propTypes.exports.oneOf(["full"]), id: propTypes.exports.string, indeterminate: propTypes.exports.bool, inline: propTypes.exports.bool, label: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]), type: propTypes.exports.oneOf(["checkbox", "radio"]) }, CFormControlValidation.propTypes);
CFormCheck.displayName = "CFormCheck";
var CFormFloating = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("form-floating", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CFormFloating.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CFormFloating.displayName = "CFormFloating";
var CFormText = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, _b = _a.component, Component = _b === void 0 ? "div" : _b, rest = __rest(_a, ["children", "className", "component"]);
  var _className = classNames("form-text", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CFormText.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CFormText.displayName = "CFormText";
var CFormControlWrapper = function(_a) {
  var children2 = _a.children, describedby = _a.describedby, feedback = _a.feedback, feedbackInvalid = _a.feedbackInvalid, feedbackValid = _a.feedbackValid, floatingLabel = _a.floatingLabel, id = _a.id, invalid = _a.invalid, label = _a.label, text = _a.text, tooltipFeedback = _a.tooltipFeedback, valid = _a.valid;
  return floatingLabel ? import_react.default.createElement(
    CFormFloating,
    null,
    children2,
    import_react.default.createElement(CFormLabel, { htmlFor: id }, label || floatingLabel)
  ) : import_react.default.createElement(
    import_react.default.Fragment,
    null,
    label && import_react.default.createElement(CFormLabel, { htmlFor: id }, label),
    children2,
    text && import_react.default.createElement(CFormText, { id: describedby }, text),
    import_react.default.createElement(CFormControlValidation, { describedby, feedback, feedbackInvalid, feedbackValid, floatingLabel, invalid, tooltipFeedback, valid })
  );
};
CFormControlWrapper.propTypes = __assign({ children: propTypes.exports.node, floatingLabel: propTypes.exports.oneOfType([propTypes.exports.node, propTypes.exports.string]), label: propTypes.exports.oneOfType([propTypes.exports.node, propTypes.exports.string]), text: propTypes.exports.oneOfType([propTypes.exports.node, propTypes.exports.string]) }, CFormControlValidation.propTypes);
CFormControlWrapper.displayName = "CFormControlWrapper";
var CFormInput = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, _c = _a.delay, delay = _c === void 0 ? false : _c, feedback = _a.feedback, feedbackInvalid = _a.feedbackInvalid, feedbackValid = _a.feedbackValid, floatingLabel = _a.floatingLabel, id = _a.id, invalid = _a.invalid, label = _a.label, onChange = _a.onChange, plainText = _a.plainText, size = _a.size, text = _a.text, tooltipFeedback = _a.tooltipFeedback, _d = _a.type, type = _d === void 0 ? "text" : _d, valid = _a.valid, rest = __rest(_a, ["children", "className", "delay", "feedback", "feedbackInvalid", "feedbackValid", "floatingLabel", "id", "invalid", "label", "onChange", "plainText", "size", "text", "tooltipFeedback", "type", "valid"]);
  var _e = (0, import_react.useState)(), value = _e[0], setValue = _e[1];
  (0, import_react.useEffect)(function() {
    var timeOutId = setTimeout(function() {
      return value && onChange && onChange(value);
    }, typeof delay === "number" ? delay : 500);
    return function() {
      return clearTimeout(timeOutId);
    };
  }, [value]);
  var _className = classNames(plainText ? "form-control-plaintext" : "form-control", (_b = {}, _b["form-control-".concat(size)] = size, _b["form-control-color"] = type === "color", _b["is-invalid"] = invalid, _b["is-valid"] = valid, _b), className);
  return import_react.default.createElement(
    CFormControlWrapper,
    { describedby: rest["aria-describedby"], feedback, feedbackInvalid, feedbackValid, floatingLabel, id, invalid, label, text, tooltipFeedback, valid },
    import_react.default.createElement("input", __assign({ className: _className, id, type, onChange: function(event) {
      return delay ? setValue(event) : onChange && onChange(event);
    } }, rest, { ref }), children2)
  );
});
CFormInput.propTypes = __assign({ className: propTypes.exports.string, id: propTypes.exports.string, delay: propTypes.exports.oneOfType([propTypes.exports.bool, propTypes.exports.number]), plainText: propTypes.exports.bool, size: propTypes.exports.oneOf(["sm", "lg"]), type: propTypes.exports.oneOfType([propTypes.exports.oneOf(["color", "file", "text"]), propTypes.exports.string]) }, CFormControlWrapper.propTypes);
CFormInput.displayName = "CFormInput";
var CFormRange = (0, import_react.forwardRef)(function(_a, ref) {
  var className = _a.className, label = _a.label, rest = __rest(_a, ["className", "label"]);
  var _className = classNames("form-range", className);
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    label && import_react.default.createElement(CFormLabel, { htmlFor: rest.id }, label),
    import_react.default.createElement("input", __assign({ type: "range", className: _className }, rest, { ref }))
  );
});
CFormRange.propTypes = {
  className: propTypes.exports.string,
  label: propTypes.exports.oneOfType([propTypes.exports.node, propTypes.exports.string])
};
CFormRange.displayName = "CFormRange";
var CFormSelect = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, feedback = _a.feedback, feedbackInvalid = _a.feedbackInvalid, feedbackValid = _a.feedbackValid, floatingLabel = _a.floatingLabel, htmlSize = _a.htmlSize, id = _a.id, invalid = _a.invalid, label = _a.label, options = _a.options, size = _a.size, text = _a.text, tooltipFeedback = _a.tooltipFeedback, valid = _a.valid, rest = __rest(_a, ["children", "className", "feedback", "feedbackInvalid", "feedbackValid", "floatingLabel", "htmlSize", "id", "invalid", "label", "options", "size", "text", "tooltipFeedback", "valid"]);
  var _className = classNames("form-select", (_b = {}, _b["form-select-".concat(size)] = size, _b["is-invalid"] = invalid, _b["is-valid"] = valid, _b), className);
  return import_react.default.createElement(
    CFormControlWrapper,
    { describedby: rest["aria-describedby"], feedback, feedbackInvalid, feedbackValid, floatingLabel, id, invalid, label, text, tooltipFeedback, valid },
    import_react.default.createElement("select", __assign({ id, className: _className, size: htmlSize }, rest, { ref }), options ? options.map(function(option, index) {
      return import_react.default.createElement("option", __assign({}, typeof option === "object" && option.disabled && { disabled: option.disabled }, typeof option === "object" && option.value && { value: option.value }, { key: index }), typeof option === "string" ? option : option.label);
    }) : children2)
  );
});
CFormSelect.propTypes = __assign({ className: propTypes.exports.string, htmlSize: propTypes.exports.number, options: propTypes.exports.array }, CFormControlWrapper.propTypes);
CFormSelect.displayName = "CFormSelect";
var CFormSwitch = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var className = _a.className, id = _a.id, invalid = _a.invalid, label = _a.label, size = _a.size, _c = _a.type, type = _c === void 0 ? "checkbox" : _c, valid = _a.valid, rest = __rest(_a, ["className", "id", "invalid", "label", "size", "type", "valid"]);
  var _className = classNames("form-check form-switch", (_b = {}, _b["form-switch-".concat(size)] = size, _b["is-invalid"] = invalid, _b["is-valid"] = valid, _b), className);
  var inputClassName = classNames("form-check-input", {
    "is-invalid": invalid,
    "is-valid": valid
  });
  var labelClassName = classNames("form-check-label");
  return import_react.default.createElement(
    "div",
    { className: _className },
    import_react.default.createElement("input", __assign({ type, className: inputClassName, id }, rest, { ref })),
    label && import_react.default.createElement(CFormLabel, __assign({ customClassName: labelClassName }, id && { htmlFor: id }), label)
  );
});
CFormSwitch.propTypes = {
  className: propTypes.exports.string,
  id: propTypes.exports.string,
  invalid: propTypes.exports.bool,
  label: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  size: propTypes.exports.oneOf(["lg", "xl"]),
  type: propTypes.exports.oneOf(["checkbox", "radio"]),
  valid: propTypes.exports.bool
};
CFormSwitch.displayName = "CFormSwitch";
var CFormTextarea = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, feedback = _a.feedback, feedbackInvalid = _a.feedbackInvalid, feedbackValid = _a.feedbackValid, floatingLabel = _a.floatingLabel, id = _a.id, invalid = _a.invalid, label = _a.label, plainText = _a.plainText, text = _a.text, tooltipFeedback = _a.tooltipFeedback, valid = _a.valid, rest = __rest(_a, ["children", "className", "feedback", "feedbackInvalid", "feedbackValid", "floatingLabel", "id", "invalid", "label", "plainText", "text", "tooltipFeedback", "valid"]);
  var _className = classNames(plainText ? "form-control-plaintext" : "form-control", {
    "is-invalid": invalid,
    "is-valid": valid
  }, className);
  return import_react.default.createElement(
    CFormControlWrapper,
    { describedby: rest["aria-describedby"], feedback, feedbackInvalid, feedbackValid, floatingLabel, id, invalid, label, text, tooltipFeedback, valid },
    import_react.default.createElement("textarea", __assign({ className: _className, id }, rest, { ref }), children2)
  );
});
CFormTextarea.propTypes = __assign({ className: propTypes.exports.string, id: propTypes.exports.string, plainText: propTypes.exports.bool }, CFormControlWrapper.propTypes);
CFormTextarea.displayName = "CFormTextarea";
var CInputGroup = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, size = _a.size, rest = __rest(_a, ["children", "className", "size"]);
  var _className = classNames("input-group", (_b = {}, _b["input-group-".concat(size)] = size, _b), className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CInputGroup.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  size: propTypes.exports.oneOf(["sm", "lg"])
};
CInputGroup.displayName = "CInputGroup";
var CInputGroupText = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, _b = _a.component, Component = _b === void 0 ? "span" : _b, rest = __rest(_a, ["children", "className", "component"]);
  var _className = classNames("input-group-text", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CInputGroupText.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CInputGroupText.displayName = "CInputGroupText";
var BREAKPOINTS$3 = [
  "xxl",
  "xl",
  "lg",
  "md",
  "sm",
  "xs"
];
var CCol = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var repsonsiveClassNames = [];
  BREAKPOINTS$3.forEach(function(bp2) {
    var breakpoint = rest[bp2];
    delete rest[bp2];
    var infix = bp2 === "xs" ? "" : "-".concat(bp2);
    if (typeof breakpoint === "number" || typeof breakpoint === "string") {
      repsonsiveClassNames.push("col".concat(infix, "-").concat(breakpoint));
    }
    if (typeof breakpoint === "boolean") {
      repsonsiveClassNames.push("col".concat(infix));
    }
    if (breakpoint && typeof breakpoint === "object") {
      if (typeof breakpoint.span === "number" || typeof breakpoint.span === "string") {
        repsonsiveClassNames.push("col".concat(infix, "-").concat(breakpoint.span));
      }
      if (typeof breakpoint.span === "boolean") {
        repsonsiveClassNames.push("col".concat(infix));
      }
      if (typeof breakpoint.order === "number" || typeof breakpoint.order === "string") {
        repsonsiveClassNames.push("order".concat(infix, "-").concat(breakpoint.order));
      }
      if (typeof breakpoint.offset === "number") {
        repsonsiveClassNames.push("offset".concat(infix, "-").concat(breakpoint.offset));
      }
    }
  });
  var _className = classNames(repsonsiveClassNames.length ? repsonsiveClassNames : "col", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
var span = propTypes.exports.oneOfType([
  propTypes.exports.bool,
  propTypes.exports.number,
  propTypes.exports.string,
  propTypes.exports.oneOf(["auto"])
]);
var col = propTypes.exports.oneOfType([
  span,
  propTypes.exports.shape({
    span,
    offset: propTypes.exports.oneOfType([propTypes.exports.number, propTypes.exports.string]),
    order: propTypes.exports.oneOfType([
      propTypes.exports.oneOf(["first", "last"]),
      propTypes.exports.number,
      propTypes.exports.string
    ])
  })
]);
CCol.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  xs: col,
  sm: col
};
CCol.displayName = "CCol";
var BREAKPOINTS$2 = [
  "xxl",
  "xl",
  "lg",
  "md",
  "sm",
  "fluid"
];
var CContainer = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var repsonsiveClassNames = [];
  BREAKPOINTS$2.forEach(function(bp2) {
    var breakpoint = rest[bp2];
    delete rest[bp2];
    breakpoint && repsonsiveClassNames.push("container-".concat(bp2));
  });
  var _className = classNames(repsonsiveClassNames.length ? repsonsiveClassNames : "container", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CContainer.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  sm: propTypes.exports.bool,
  md: propTypes.exports.bool,
  lg: propTypes.exports.bool,
  xl: propTypes.exports.bool,
  xxl: propTypes.exports.bool,
  fluid: propTypes.exports.bool
};
CContainer.displayName = "CContainer";
var BREAKPOINTS$1 = [
  "xxl",
  "xl",
  "lg",
  "md",
  "sm",
  "xs"
];
var CRow = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var repsonsiveClassNames = [];
  BREAKPOINTS$1.forEach(function(bp2) {
    var breakpoint = rest[bp2];
    delete rest[bp2];
    var infix = bp2 === "xs" ? "" : "-".concat(bp2);
    if (typeof breakpoint === "object") {
      if (breakpoint.cols) {
        repsonsiveClassNames.push("row-cols".concat(infix, "-").concat(breakpoint.cols));
      }
      if (typeof breakpoint.gutter === "number") {
        repsonsiveClassNames.push("g".concat(infix, "-").concat(breakpoint.gutter));
      }
      if (typeof breakpoint.gutterX === "number") {
        repsonsiveClassNames.push("gx".concat(infix, "-").concat(breakpoint.gutterX));
      }
      if (typeof breakpoint.gutterY === "number") {
        repsonsiveClassNames.push("gy".concat(infix, "-").concat(breakpoint.gutterY));
      }
    }
  });
  var _className = classNames("row", repsonsiveClassNames, className);
  return import_react.default.createElement("div", { className: _className, ref }, children2);
});
var bp = propTypes.exports.shape({
  cols: propTypes.exports.oneOfType([propTypes.exports.oneOf(["auto"]), propTypes.exports.number, propTypes.exports.string]),
  gutter: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.number]),
  gutterX: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.number]),
  gutterY: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.number])
});
CRow.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  xs: bp,
  sm: bp,
  md: bp,
  lg: bp,
  xl: bp,
  xxl: bp
};
CRow.displayName = "CRow";
var CHeader = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, container = _a.container, position = _a.position, rest = __rest(_a, ["children", "className", "container", "position"]);
  var _className = classNames("header", (_b = {}, _b["header-".concat(position)] = position, _b), className);
  var content;
  if (container) {
    content = import_react.default.createElement("div", { className: "container".concat(container !== true ? "-" + container : "") }, children2);
  } else {
    content = children2;
  }
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), content);
});
CHeader.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  container: propTypes.exports.oneOfType([
    propTypes.exports.bool,
    propTypes.exports.oneOf([
      "sm",
      "md",
      "lg",
      "xl",
      "xxl",
      "fluid"
    ])
  ]),
  position: propTypes.exports.oneOf(["fixed", "sticky"])
};
CHeader.displayName = "CHeader";
var CHeaderBrand = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, _b = _a.component, Component = _b === void 0 ? "a" : _b, className = _a.className, rest = __rest(_a, ["children", "component", "className"]);
  var _className = classNames("header-brand", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CHeaderBrand.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CHeaderBrand.displayName = "CHeaderBrand";
var CHeaderDivider = (0, import_react.forwardRef)(function(_a, ref) {
  var className = _a.className, rest = __rest(_a, ["className"]);
  var _className = classNames("header-divider", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }));
});
CHeaderDivider.propTypes = {
  className: propTypes.exports.string
};
CHeaderDivider.displayName = "CHeaderDivider";
var CHeaderNav = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, _b = _a.component, Component = _b === void 0 ? "ul" : _b, className = _a.className, rest = __rest(_a, ["children", "component", "className"]);
  var _className = classNames("header-nav", className);
  return import_react.default.createElement(Component, __assign({ className: _className, role: "navigation" }, rest, { ref }), children2);
});
CHeaderNav.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CHeaderNav.displayName = "CHeaderNav";
var CHeaderText = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("header-text", className);
  return import_react.default.createElement("span", __assign({ className: _className }, rest, { ref }), children2);
});
CHeaderText.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CHeaderText.displayName = "CHeaderText";
var CHeaderToggler = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("header-toggler", className);
  return import_react.default.createElement("button", __assign({ type: "button", className: _className }, rest, { ref }), children2 ? children2 : import_react.default.createElement("span", { className: "header-toggler-icon" }));
});
CHeaderToggler.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CHeaderToggler.displayName = "CHeaderToggler";
var CImage = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var align = _a.align, className = _a.className, fluid = _a.fluid, rounded = _a.rounded, thumbnail = _a.thumbnail, rest = __rest(_a, ["align", "className", "fluid", "rounded", "thumbnail"]);
  var _className = classNames((_b = {}, _b["float-".concat(align)] = align && (align === "start" || align === "end"), _b["d-block mx-auto"] = align && align === "center", _b["img-fluid"] = fluid, _b.rounded = rounded, _b["img-thumbnail"] = thumbnail, _b), className);
  return import_react.default.createElement("img", __assign({ className: _className }, rest, { ref }));
});
CImage.propTypes = {
  align: propTypes.exports.oneOf(["start", "center", "end"]),
  className: propTypes.exports.string,
  fluid: propTypes.exports.bool,
  rounded: propTypes.exports.bool,
  thumbnail: propTypes.exports.bool
};
CImage.displayName = "CImage";
var CListGroup = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, _c = _a.component, Component = _c === void 0 ? "ul" : _c, flush = _a.flush, layout = _a.layout;
  var _className = classNames("list-group", (_b = {
    "list-group-flush": flush
  }, _b["list-group-".concat(layout)] = layout, _b), className);
  return import_react.default.createElement(Component, { className: _className, ref }, children2);
});
CListGroup.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType,
  flush: propTypes.exports.bool,
  layout: propTypes.exports.oneOf([
    "horizontal",
    "horizontal-sm",
    "horizontal-md",
    "horizontal-lg",
    "horizontal-xl",
    "horizontal-xxl"
  ])
};
CListGroup.displayName = "CListGroup";
var CListGroupItem = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, active = _a.active, className = _a.className, disabled = _a.disabled, color = _a.color, _c = _a.component, component = _c === void 0 ? "li" : _c, rest = __rest(_a, ["children", "active", "className", "disabled", "color", "component"]);
  var _className = classNames("list-group-item", (_b = {}, _b["list-group-item-".concat(color)] = color, _b["list-group-item-action"] = component === "a" || component === "button", _b.active = active, _b.disabled = disabled, _b), className);
  var Component = component === "a" || component === "button" ? CLink : component;
  rest = __assign(__assign(__assign(__assign({}, (component === "a" || component === "button") && {
    active,
    disabled,
    component,
    ref
  }), active && { "aria-current": true }), disabled && { "aria-disabled": true }), rest);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest), children2);
});
CListGroupItem.propTypes = {
  active: propTypes.exports.bool,
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType,
  component: propTypes.exports.elementType,
  disabled: propTypes.exports.bool
};
CListGroupItem.displayName = "CListGroupItem";
var CModalContent = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("modal-content", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CModalContent.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CModalContent.displayName = "CModalContent";
var CModalDialog = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, alignment = _a.alignment, className = _a.className, fullscreen = _a.fullscreen, scrollable = _a.scrollable, size = _a.size, rest = __rest(_a, ["children", "alignment", "className", "fullscreen", "scrollable", "size"]);
  var _className = classNames("modal-dialog", (_b = {
    "modal-dialog-centered": alignment === "center"
  }, _b[typeof fullscreen === "boolean" ? "modal-fullscreen" : "modal-fullscreen-".concat(fullscreen, "-down")] = fullscreen, _b["modal-dialog-scrollable"] = scrollable, _b["modal-".concat(size)] = size, _b), className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CModalDialog.propTypes = {
  alignment: propTypes.exports.oneOf(["top", "center"]),
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  fullscreen: propTypes.exports.oneOfType([
    propTypes.exports.bool,
    propTypes.exports.oneOf(["sm", "md", "lg", "xl", "xxl"])
  ]),
  scrollable: propTypes.exports.bool,
  size: propTypes.exports.oneOf(["sm", "lg", "xl"])
};
CModalDialog.displayName = "CModalDialog";
var CModalContext = (0, import_react.createContext)({});
var CModal = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, alignment = _a.alignment, _b = _a.backdrop, backdrop = _b === void 0 ? true : _b, className = _a.className, _c = _a.duration, duration = _c === void 0 ? 150 : _c, fullscreen = _a.fullscreen, _d = _a.keyboard, keyboard = _d === void 0 ? true : _d, onClose = _a.onClose, onClosePrevented = _a.onClosePrevented, onShow = _a.onShow, _e = _a.portal, portal = _e === void 0 ? true : _e, scrollable = _a.scrollable, size = _a.size, _f = _a.transition, transition = _f === void 0 ? true : _f, _g = _a.unmountOnClose, unmountOnClose = _g === void 0 ? true : _g, visible = _a.visible;
  var modalRef = (0, import_react.useRef)(null);
  var modalContentRef = (0, import_react.useRef)(null);
  var forkedRef = useForkedRef(ref, modalRef);
  var _h = (0, import_react.useState)(visible), _visible = _h[0], setVisible = _h[1];
  var _j = (0, import_react.useState)(false), staticBackdrop = _j[0], setStaticBackdrop = _j[1];
  (0, import_react.useEffect)(function() {
    setVisible(visible);
  }, [visible]);
  var contextValues = {
    visible: _visible,
    setVisible
  };
  (0, import_react.useEffect)(function() {
    modalRef.current && modalRef.current.addEventListener("click", handleClickOutside);
    modalRef.current && modalRef.current.addEventListener("keyup", handleKeyDown);
    return function() {
      modalRef.current && modalRef.current.removeEventListener("click", handleClickOutside);
      modalRef.current && modalRef.current.removeEventListener("keyup", handleKeyDown);
    };
  }, [_visible]);
  var handleDismiss = function() {
    if (backdrop === "static") {
      return setStaticBackdrop(true);
    }
    return onClose && onClose();
  };
  (0, import_react.useLayoutEffect)(function() {
    onClosePrevented && onClosePrevented();
    setTimeout(function() {
      return setStaticBackdrop(false);
    }, duration);
  }, [staticBackdrop]);
  var getTransitionClass = function(state) {
    return state === "entering" ? "d-block" : state === "entered" ? "show d-block" : state === "exiting" ? "d-block" : "";
  };
  var _className = classNames("modal", {
    "modal-static": staticBackdrop,
    fade: transition
  }, className);
  (0, import_react.useLayoutEffect)(function() {
    if (_visible) {
      document.body.classList.add("modal-open");
      if (backdrop) {
        document.body.style.overflow = "hidden";
        document.body.style.paddingRight = "0px";
      }
      setTimeout(function() {
        var _a2;
        (_a2 = modalRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
      }, !transition ? 0 : duration);
    } else {
      document.body.classList.remove("modal-open");
      if (backdrop) {
        document.body.style.removeProperty("overflow");
        document.body.style.removeProperty("padding-right");
      }
    }
    return function() {
      document.body.classList.remove("modal-open");
      if (backdrop) {
        document.body.style.removeProperty("overflow");
        document.body.style.removeProperty("padding-right");
      }
    };
  }, [_visible]);
  var handleClickOutside = function(event) {
    if (modalContentRef.current && !modalContentRef.current.contains(event.target)) {
      handleDismiss();
    }
  };
  var handleKeyDown = (0, import_react.useCallback)(function(event) {
    if (event.key === "Escape" && keyboard) {
      return handleDismiss();
    }
  }, [modalRef, handleDismiss]);
  var modal = function(ref2, transitionClass) {
    return import_react.default.createElement(
      CModalContext.Provider,
      { value: contextValues },
      import_react.default.createElement(
        "div",
        { className: classNames(_className, transitionClass), tabIndex: -1, role: "dialog", ref: ref2 },
        import_react.default.createElement(
          CModalDialog,
          { alignment, fullscreen, scrollable, size },
          import_react.default.createElement(CModalContent, { ref: modalContentRef }, children2)
        )
      )
    );
  };
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    import_react.default.createElement(Transition, { in: _visible, mountOnEnter: true, nodeRef: modalRef, onEnter: onShow, onExit: onClose, unmountOnExit: unmountOnClose, timeout: !transition ? 0 : duration }, function(state) {
      var transitionClass = getTransitionClass(state);
      return typeof window !== "undefined" && portal ? (0, import_react_dom.createPortal)(modal(forkedRef, transitionClass), document.body) : modal(forkedRef, transitionClass);
    }),
    typeof window !== "undefined" && portal ? backdrop && (0, import_react_dom.createPortal)(import_react.default.createElement(CBackdrop, { visible: _visible }), document.body) : backdrop && import_react.default.createElement(CBackdrop, { visible: _visible })
  );
});
CModal.propTypes = {
  alignment: propTypes.exports.oneOf(["top", "center"]),
  backdrop: propTypes.exports.oneOfType([propTypes.exports.bool, propTypes.exports.oneOf(["static"])]),
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  duration: propTypes.exports.number,
  fullscreen: propTypes.exports.oneOfType([
    propTypes.exports.bool,
    propTypes.exports.oneOf(["sm", "md", "lg", "xl", "xxl"])
  ]),
  keyboard: propTypes.exports.bool,
  onClose: propTypes.exports.func,
  onClosePrevented: propTypes.exports.func,
  onShow: propTypes.exports.func,
  portal: propTypes.exports.bool,
  scrollable: propTypes.exports.bool,
  size: propTypes.exports.oneOf(["sm", "lg", "xl"]),
  transition: propTypes.exports.bool,
  unmountOnClose: propTypes.exports.bool,
  visible: propTypes.exports.bool
};
CModal.displayName = "CModal";
var CModalBody = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("modal-body", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CModalBody.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CModalBody.displayName = "CModalBody";
var CModalFooter = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("modal-footer", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CModalFooter.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CModalFooter.displayName = "CModalFooter";
var CModalHeader = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, _b = _a.closeButton, closeButton = _b === void 0 ? true : _b, rest = __rest(_a, ["children", "className", "closeButton"]);
  var setVisible = (0, import_react.useContext)(CModalContext).setVisible;
  var _className = classNames("modal-header", className);
  return import_react.default.createElement(
    "div",
    __assign({ className: _className }, rest, { ref }),
    children2,
    closeButton && import_react.default.createElement(CCloseButton, { onClick: function() {
      return setVisible(false);
    } })
  );
});
CModalHeader.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  closeButton: propTypes.exports.bool
};
CModalHeader.displayName = "CModalHeader";
var CModalTitle = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, _b = _a.component, Component = _b === void 0 ? "h5" : _b, className = _a.className, rest = __rest(_a, ["children", "component", "className"]);
  var _className = classNames("modal-title", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CModalTitle.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CModalTitle.displayName = "CModalTitle";
var CNav = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, _c = _a.component, Component = _c === void 0 ? "ul" : _c, layout = _a.layout, variant = _a.variant, rest = __rest(_a, ["children", "className", "component", "layout", "variant"]);
  var _className = classNames("nav", (_b = {}, _b["nav-".concat(layout)] = layout, _b["nav-".concat(variant)] = variant, _b), className);
  return import_react.default.createElement(Component, __assign({ className: _className, role: "navigation" }, rest, { ref }), children2);
});
CNav.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType,
  layout: propTypes.exports.oneOf(["fill", "justified"]),
  variant: propTypes.exports.oneOf(["tabs", "pills"])
};
CNav.displayName = "CNav";
var CNavGroupItems = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("nav-group-items", className);
  return import_react.default.createElement("ul", __assign({ className: _className }, rest, { ref }), children2);
});
CNavGroupItems.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CNavGroupItems.displayName = "CNavGroupItems";
var CNavContext = (0, import_react.createContext)({});
var CSidebarNav = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _b = (0, import_react.useState)(""), visibleGroup = _b[0], setVisibleGroup = _b[1];
  var CNavContextValues = {
    visibleGroup,
    setVisibleGroup
  };
  var classes = classNames("sidebar-nav", className);
  return import_react.default.createElement(
    "ul",
    __assign({ className: classes, ref }, rest),
    import_react.default.createElement(CNavContext.Provider, { value: CNavContextValues }, import_react.default.Children.map(children2, function(child, index) {
      if (import_react.default.isValidElement(child)) {
        return import_react.default.cloneElement(child, {
          key: index,
          idx: "".concat(index)
        });
      }
      return;
    }))
  );
});
CSidebarNav.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CSidebarNav.displayName = "CSidebarNav";
var CNavGroup = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, compact = _a.compact, idx = _a.idx, toggler = _a.toggler, visible = _a.visible, rest = __rest(_a, ["children", "className", "compact", "idx", "toggler", "visible"]);
  var _b = (0, import_react.useState)(), height = _b[0], setHeight = _b[1];
  var navItemsRef = (0, import_react.useRef)(null);
  var _c = (0, import_react.useContext)(CNavContext), visibleGroup = _c.visibleGroup, setVisibleGroup = _c.setVisibleGroup;
  var _d = (0, import_react.useState)(Boolean(visible || idx && visibleGroup && visibleGroup.toString().startsWith(idx.toString()))), _visible = _d[0], setVisible = _d[1];
  (0, import_react.useEffect)(function() {
    setVisible(Boolean(idx && visibleGroup && visibleGroup.toString().startsWith(idx.toString())));
  }, [visibleGroup]);
  var handleTogglerOnCLick = function(event) {
    event.preventDefault();
    setVisibleGroup(_visible ? (idx === null || idx === void 0 ? void 0 : idx.toString().includes(".")) ? idx.slice(0, idx.lastIndexOf(".")) : "" : idx);
    setVisible(!_visible);
  };
  var style = {
    height: 0
  };
  var onEntering = function() {
    navItemsRef.current && setHeight(navItemsRef.current.scrollHeight);
  };
  var onEntered = function() {
    setHeight("auto");
  };
  var onExit = function() {
    navItemsRef.current && setHeight(navItemsRef.current.scrollHeight);
  };
  var onExiting = function() {
    var _a2;
    (_a2 = navItemsRef.current) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight;
    setHeight(0);
  };
  var onExited = function() {
    setHeight(0);
  };
  var transitionStyles = {
    entering: { display: "block", height },
    entered: { display: "block", height },
    exiting: { display: "block", height },
    exited: { height }
  };
  var _className = classNames("nav-group", { show: _visible }, className);
  return import_react.default.createElement(
    "li",
    __assign({ className: _className }, rest, { ref }),
    toggler && import_react.default.createElement("a", { className: "nav-link nav-group-toggle", onClick: function(event) {
      return handleTogglerOnCLick(event);
    } }, toggler),
    import_react.default.createElement(Transition, { in: _visible, nodeRef: navItemsRef, onEntering, onEntered, onExit, onExiting, onExited, timeout: 300 }, function(state) {
      return import_react.default.createElement("ul", { className: classNames("nav-group-items", {
        compact
      }), style: __assign(__assign({}, style), transitionStyles[state]), ref: navItemsRef }, import_react.default.Children.map(children2, function(child, index) {
        if (import_react.default.isValidElement(child)) {
          return import_react.default.cloneElement(child, {
            key: index,
            idx: "".concat(idx, ".").concat(index)
          });
        }
        return;
      }));
    })
  );
});
CNavGroup.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  compact: propTypes.exports.bool,
  idx: propTypes.exports.string,
  toggler: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  visible: propTypes.exports.bool
};
CNavGroup.displayName = "CNavGroup";
var CNavLink = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, idx = _a.idx, rest = __rest(_a, ["children", "className", "idx"]);
  var navLinkRef = (0, import_react.useRef)(null);
  var forkedRef = useForkedRef(ref, navLinkRef);
  var setVisibleGroup = (0, import_react.useContext)(CNavContext).setVisibleGroup;
  var _className = classNames("nav-link", className);
  (0, import_react.useEffect)(function() {
    var _a2;
    rest.active = (_a2 = navLinkRef.current) === null || _a2 === void 0 ? void 0 : _a2.classList.contains("active");
    idx && rest.active && setVisibleGroup(idx);
  }, [rest.active, className]);
  return import_react.default.createElement(CLink, __assign({ className: _className }, rest, { ref: forkedRef }), children2);
});
CNavLink.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  idx: propTypes.exports.string
};
CNavLink.displayName = "CNavLink";
var CNavItem = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("nav-item", className);
  if (rest.href || rest.to) {
    children2 = import_react.default.createElement(CNavLink, __assign({ className }, rest), children2);
  }
  return import_react.default.createElement("li", { className: _className, ref }, children2);
});
CNavItem.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CNavItem.displayName = "CNavItem";
var CNavTitle = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("nav-title", className);
  return import_react.default.createElement("li", __assign({ className: _className }, rest, { ref }), children2);
});
CNavTitle.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CNavTitle.displayName = "CNavTitle";
var CNavbar = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, color = _a.color, colorScheme = _a.colorScheme, _c = _a.component, Component = _c === void 0 ? "nav" : _c, container = _a.container, expand = _a.expand, placement = _a.placement, rest = __rest(_a, ["children", "className", "color", "colorScheme", "component", "container", "expand", "placement"]);
  var _className = classNames("navbar", (_b = {}, _b["bg-".concat(color)] = color, _b["navbar-".concat(colorScheme)] = colorScheme, _b[typeof expand === "boolean" ? "navbar-expand" : "navbar-expand-".concat(expand)] = expand, _b), placement, className);
  var content;
  if (container) {
    content = import_react.default.createElement("div", { className: "container".concat(container !== true ? "-" + container : "") }, children2);
  } else {
    content = children2;
  }
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), content);
});
CNavbar.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType,
  colorScheme: propTypes.exports.oneOf(["dark", "light"]),
  component: propTypes.exports.elementType,
  container: propTypes.exports.oneOfType([
    propTypes.exports.bool,
    propTypes.exports.oneOf([
      "sm",
      "md",
      "lg",
      "xl",
      "xxl",
      "fluid"
    ])
  ]),
  expand: propTypes.exports.oneOfType([
    propTypes.exports.bool,
    propTypes.exports.oneOf(["sm", "md", "lg", "xl", "xxl"])
  ]),
  placement: propTypes.exports.oneOf(["fixed-top", "fixed-bottom", "sticky-top"])
};
CNavbar.displayName = "CNavbar";
var CNavbarBrand = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, component = _a.component, className = _a.className, rest = __rest(_a, ["children", "component", "className"]);
  var Component = component ? component : rest.href ? "a" : "span";
  var _className = classNames("navbar-brand", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CNavbarBrand.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CNavbarBrand.displayName = "CNavbarBrand";
var CNavbarNav = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, _b = _a.component, Component = _b === void 0 ? "ul" : _b, className = _a.className, rest = __rest(_a, ["children", "component", "className"]);
  var _className = classNames("navbar-nav", className);
  return import_react.default.createElement(Component, __assign({ className: _className, role: "navigation" }, rest, { ref }), children2);
});
CNavbarNav.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CNavbarNav.displayName = "CNavbarNav";
var CNavbarText = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("navbar-text", className);
  return import_react.default.createElement("span", __assign({ className: _className }, rest, { ref }), children2);
});
CNavbarText.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CNavbarText.displayName = "CNavbarText";
var CNavbarToggler = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("navbar-toggler", className);
  return import_react.default.createElement("button", __assign({ type: "button", className: _className }, rest, { ref }), children2 ? children2 : import_react.default.createElement("span", { className: "navbar-toggler-icon" }));
});
CNavbarToggler.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CNavbarToggler.displayName = "CNavbarToggler";
var COffcanvas = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, _c = _a.backdrop, backdrop = _c === void 0 ? true : _c, className = _a.className, _d = _a.keyboard, keyboard = _d === void 0 ? true : _d, onHide = _a.onHide, onShow = _a.onShow, placement = _a.placement, _e = _a.portal, portal = _e === void 0 ? true : _e, _f = _a.scroll, scroll = _f === void 0 ? false : _f, _g = _a.visible, visible = _g === void 0 ? false : _g, rest = __rest(_a, ["children", "backdrop", "className", "keyboard", "onHide", "onShow", "placement", "portal", "scroll", "visible"]);
  var _h = (0, import_react.useState)(visible), _visible = _h[0], setVisible = _h[1];
  var offcanvasRef = (0, import_react.useRef)(null);
  var forkedRef = useForkedRef(ref, offcanvasRef);
  (0, import_react.useEffect)(function() {
    setVisible(visible);
  }, [visible]);
  (0, import_react.useEffect)(function() {
    if (_visible) {
      if (!scroll) {
        document.body.style.overflow = "hidden";
        document.body.style.paddingRight = "0px";
      }
      return;
    }
    if (!scroll) {
      document.body.style.removeProperty("overflow");
      document.body.style.removeProperty("padding-right");
    }
  }, [_visible]);
  var _className = classNames("offcanvas", (_b = {}, _b["offcanvas-".concat(placement)] = placement, _b.show = _visible, _b), className);
  var transitionStyles = {
    entering: { visibility: "visible" },
    entered: { visibility: "visible" },
    exiting: { visibility: "visible" },
    exited: { visibility: "hidden" }
  };
  var handleDismiss = function() {
    setVisible(false);
  };
  var handleKeyDown = (0, import_react.useCallback)(function(event) {
    if (event.key === "Escape" && keyboard) {
      return handleDismiss();
    }
  }, [ref, handleDismiss]);
  var offcanvas = function(ref2, state) {
    return import_react.default.createElement(
      import_react.default.Fragment,
      null,
      import_react.default.createElement("div", __assign({ className: _className, role: "dialog", style: __assign({}, transitionStyles[state]), tabIndex: -1, onKeyDown: handleKeyDown }, rest, { ref: ref2 }), children2)
    );
  };
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    import_react.default.createElement(Transition, { in: _visible, nodeRef: offcanvasRef, onEnter: onShow, onEntered: function() {
      var _a2;
      return (_a2 = offcanvasRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    }, onExit: onHide, timeout: 300 }, function(state) {
      return typeof window !== "undefined" && portal ? (0, import_react_dom.createPortal)(offcanvas(forkedRef, state), document.body) : offcanvas(forkedRef, state);
    }),
    typeof window !== "undefined" && portal ? backdrop && (0, import_react_dom.createPortal)(import_react.default.createElement(CBackdrop, { className: "offcanvas-backdrop", onClick: handleDismiss, visible: _visible }), document.body) : backdrop && import_react.default.createElement(CBackdrop, { className: "offcanvas-backdrop", onClick: handleDismiss, visible: _visible })
  );
});
COffcanvas.propTypes = {
  backdrop: propTypes.exports.bool,
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  keyboard: propTypes.exports.bool,
  onHide: propTypes.exports.func,
  onShow: propTypes.exports.func,
  placement: propTypes.exports.oneOf(["start", "end", "top", "bottom"]).isRequired,
  portal: propTypes.exports.bool,
  scroll: propTypes.exports.bool,
  visible: propTypes.exports.bool
};
COffcanvas.displayName = "COffcanvas";
var COffcanvasBody = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("offcanvas-body", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
COffcanvasBody.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
COffcanvasBody.displayName = "COffcanvasBody";
var COffcanvasHeader = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("offcanvas-header", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
COffcanvasHeader.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
COffcanvasHeader.displayName = "COffcanvasHeader";
var COffcanvasTitle = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, _b = _a.component, Component = _b === void 0 ? "h5" : _b, className = _a.className, rest = __rest(_a, ["children", "component", "className"]);
  var _className = classNames("offcanvas-title", className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
COffcanvasTitle.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
COffcanvasTitle.displayName = "COffcanvasTitle";
var CPagination = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, align = _a.align, className = _a.className, size = _a.size, rest = __rest(_a, ["children", "align", "className", "size"]);
  var _className = classNames("pagination", (_b = {}, _b["justify-content-".concat(align)] = align, _b["pagination-".concat(size)] = size, _b), className);
  return import_react.default.createElement(
    "nav",
    __assign({ ref }, rest),
    import_react.default.createElement("ul", { className: _className }, children2)
  );
});
CPagination.propTypes = {
  align: propTypes.exports.oneOf(["start", "center", "end"]),
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  size: propTypes.exports.oneOf(["sm", "lg"])
};
CPagination.displayName = "CPagination";
var CPaginationItem = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, component = _a.component, rest = __rest(_a, ["children", "className", "component"]);
  var _className = classNames("page-item", {
    active: rest.active,
    disabled: rest.disabled
  }, className);
  var Component = component ? component : rest.active ? "span" : "a";
  return import_react.default.createElement("li", __assign({ className: _className }, rest.active && { "aria-current": "page" }), Component === "a" ? import_react.default.createElement(CLink, __assign({ className: "page-link", component: Component }, rest, { ref }), children2) : import_react.default.createElement(Component, { className: "page-link", ref }, children2));
});
CPaginationItem.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  component: propTypes.exports.elementType
};
CPaginationItem.displayName = "CPaginationItem";
var BREAKPOINTS = [
  "xxl",
  "xl",
  "lg",
  "md",
  "sm",
  "xs"
];
var CPlaceholder = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, animation = _a.animation, className = _a.className, color = _a.color, _c = _a.component, Component = _c === void 0 ? "span" : _c, size = _a.size, rest = __rest(_a, ["children", "animation", "className", "color", "component", "size"]);
  var repsonsiveClassNames = [];
  BREAKPOINTS.forEach(function(bp2) {
    var breakpoint = rest[bp2];
    delete rest[bp2];
    var infix = bp2 === "xs" ? "" : "-".concat(bp2);
    if (typeof breakpoint === "number") {
      repsonsiveClassNames.push("col".concat(infix, "-").concat(breakpoint));
    }
    if (typeof breakpoint === "boolean") {
      repsonsiveClassNames.push("col".concat(infix));
    }
  });
  var _className = classNames(animation ? "placeholder-".concat(animation) : "placeholder", (_b = {}, _b["bg-".concat(color)] = color, _b["placeholder-".concat(size)] = size, _b), repsonsiveClassNames, className);
  return import_react.default.createElement(Component, __assign({ className: _className }, rest, { ref }), children2);
});
CPlaceholder.propTypes = {
  animation: propTypes.exports.oneOf(["glow", "wave"]),
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType,
  component: propTypes.exports.elementType,
  size: propTypes.exports.oneOf(["xs", "sm", "lg"])
};
CPlaceholder.displayName = "CPlaceholder";
var CProgressBar = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, animated = _a.animated, className = _a.className, color = _a.color, _c = _a.value, value = _c === void 0 ? 0 : _c, variant = _a.variant, rest = __rest(_a, ["children", "animated", "className", "color", "value", "variant"]);
  var _className = classNames("progress-bar", (_b = {}, _b["bg-".concat(color)] = color, _b["progress-bar-".concat(variant)] = variant, _b["progress-bar-animated"] = animated, _b), className);
  return import_react.default.createElement("div", __assign({ className: _className, role: "progressbar", style: { width: "".concat(value, "%") }, "aria-valuenow": value, "aria-valuemin": 0, "aria-valuemax": 100 }, rest, { ref }), children2);
});
CProgressBar.propTypes = {
  animated: propTypes.exports.bool,
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType,
  value: propTypes.exports.number,
  variant: propTypes.exports.oneOf(["striped"])
};
CProgressBar.displayName = "CProgressBar";
var CProgress = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, height = _a.height, thin = _a.thin, _b = _a.value, value = _b === void 0 ? 0 : _b, white = _a.white, rest = __rest(_a, ["children", "className", "height", "thin", "value", "white"]);
  var _className = classNames("progress", {
    "progress-thin": thin,
    "progress-white": white
  }, className);
  return import_react.default.createElement("div", { className: _className, style: height ? { height: "".concat(height, "px") } : {}, ref }, value ? import_react.default.createElement(CProgressBar, __assign({ value }, rest), children2) : children2);
});
CProgress.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  height: propTypes.exports.number,
  thin: propTypes.exports.bool,
  value: propTypes.exports.number,
  white: propTypes.exports.bool
};
CProgress.displayName = "CProgress";
var CPopover = function(_a) {
  var children2 = _a.children, content = _a.content, _b = _a.offset, offset2 = _b === void 0 ? [0, 8] : _b, onHide = _a.onHide, onShow = _a.onShow, _c = _a.placement, placement = _c === void 0 ? "top" : _c, title = _a.title, _d = _a.trigger, trigger = _d === void 0 ? "click" : _d, visible = _a.visible, rest = __rest(_a, ["children", "content", "offset", "onHide", "onShow", "placement", "title", "trigger", "visible"]);
  var _e = (0, import_react.useState)(visible), _visible = _e[0], setVisible = _e[1];
  var popoverRef = (0, import_react.useRef)();
  var _f = (0, import_react.useState)(null), referenceElement = _f[0], setReferenceElement = _f[1];
  var _g = (0, import_react.useState)(null), popperElement = _g[0], setPopperElement = _g[1];
  var _h = (0, import_react.useState)(null), arrowElement = _h[0], setArrowElement = _h[1];
  var _j = usePopper(referenceElement, popperElement, {
    modifiers: [
      { name: "arrow", options: { element: arrowElement } },
      {
        name: "offset",
        options: {
          offset: offset2
        }
      }
    ],
    placement
  }), styles = _j.styles, attributes = _j.attributes;
  (0, import_react.useEffect)(function() {
    setVisible(visible);
  }, [visible]);
  var getTransitionClass = function(state) {
    return state === "entering" ? "fade" : state === "entered" ? "fade show" : state === "exiting" ? "fade" : "fade";
  };
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    import_react.default.cloneElement(children2, __assign(__assign(__assign({ ref: setReferenceElement }, (trigger === "click" || trigger.includes("click")) && {
      onClick: function() {
        return setVisible(!_visible);
      }
    }), (trigger === "focus" || trigger.includes("focus")) && {
      onFocus: function() {
        return setVisible(true);
      },
      onBlur: function() {
        return setVisible(false);
      }
    }), (trigger === "hover" || trigger.includes("hover")) && {
      onMouseEnter: function() {
        return setVisible(true);
      },
      onMouseLeave: function() {
        return setVisible(false);
      }
    })),
    typeof window !== "undefined" && (0, import_react_dom.createPortal)(import_react.default.createElement(Transition, { in: _visible, mountOnEnter: true, nodeRef: popoverRef, onEnter: onShow, onExit: onHide, timeout: {
      enter: 0,
      exit: 200
    }, unmountOnExit: true }, function(state) {
      var transitionClass = getTransitionClass(state);
      return import_react.default.createElement(
        "div",
        __assign({ className: classNames("popover bs-popover-".concat(placement === "left" ? "start" : placement === "right" ? "end" : placement), transitionClass), ref: setPopperElement, role: "tooltip", style: styles.popper }, attributes.popper, rest),
        import_react.default.createElement("div", { className: "popover-arrow", style: styles.arrow, ref: setArrowElement }),
        import_react.default.createElement("div", { className: "popover-header" }, title),
        import_react.default.createElement("div", { className: "popover-body" }, content)
      );
    }), document.body)
  );
};
CPopover.propTypes = {
  children: propTypes.exports.any,
  content: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  offset: propTypes.exports.any,
  onHide: propTypes.exports.func,
  onShow: propTypes.exports.func,
  placement: propTypes.exports.oneOf(["auto", "top", "right", "bottom", "left"]),
  title: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  trigger: triggerPropType,
  visible: propTypes.exports.bool
};
CPopover.displayName = "CPopover";
var isOnMobile = function(element) {
  return Boolean(getComputedStyle(element).getPropertyValue("--cui-is-mobile"));
};
var isVisible = function(element) {
  var rect = element.getBoundingClientRect();
  return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
};
var CSidebar = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, narrow = _a.narrow, onHide = _a.onHide, onShow = _a.onShow, onVisibleChange = _a.onVisibleChange, overlaid = _a.overlaid, position = _a.position, size = _a.size, unfoldable = _a.unfoldable, visible = _a.visible, rest = __rest(_a, ["children", "className", "narrow", "onHide", "onShow", "onVisibleChange", "overlaid", "position", "size", "unfoldable", "visible"]);
  var sidebarRef = (0, import_react.useRef)(null);
  var forkedRef = useForkedRef(ref, sidebarRef);
  var _c = (0, import_react.useState)(false), mobile = _c[0], setMobile = _c[1];
  var _d = (0, import_react.useState)(visible), _visible = _d[0], setVisible = _d[1];
  var _e = (0, import_react.useState)(), inViewport = _e[0], setInViewport = _e[1];
  (0, import_react.useEffect)(function() {
    sidebarRef.current && setMobile(isOnMobile(sidebarRef.current));
    setVisible(visible);
  }, [visible]);
  (0, import_react.useEffect)(function() {
    typeof inViewport !== "undefined" && onVisibleChange && onVisibleChange(inViewport);
    !inViewport && onHide && onHide();
    inViewport && onShow && onShow();
  }, [inViewport]);
  (0, import_react.useEffect)(function() {
    mobile && visible && setVisible(false);
  }, [mobile]);
  (0, import_react.useEffect)(function() {
    var _a2, _b2;
    sidebarRef.current && setMobile(isOnMobile(sidebarRef.current));
    sidebarRef.current && setInViewport(isVisible(sidebarRef.current));
    window.addEventListener("resize", function() {
      return handleResize();
    });
    window.addEventListener("mouseup", handleClickOutside);
    window.addEventListener("keyup", handleKeyup);
    (_a2 = sidebarRef.current) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("mouseup", handleOnClick);
    (_b2 = sidebarRef.current) === null || _b2 === void 0 ? void 0 : _b2.addEventListener("transitionend", function() {
      sidebarRef.current && setInViewport(isVisible(sidebarRef.current));
    });
    return function() {
      var _a3, _b3;
      window.removeEventListener("resize", function() {
        return handleResize();
      });
      window.removeEventListener("mouseup", handleClickOutside);
      window.removeEventListener("keyup", handleKeyup);
      (_a3 = sidebarRef.current) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener("mouseup", handleOnClick);
      (_b3 = sidebarRef.current) === null || _b3 === void 0 ? void 0 : _b3.removeEventListener("transitionend", function() {
        sidebarRef.current && setInViewport(isVisible(sidebarRef.current));
      });
    };
  });
  var handleHide = function() {
    setVisible(false);
  };
  var handleResize = function() {
    sidebarRef.current && setMobile(isOnMobile(sidebarRef.current));
    sidebarRef.current && setInViewport(isVisible(sidebarRef.current));
  };
  var handleKeyup = function(event) {
    if (mobile && sidebarRef.current && !sidebarRef.current.contains(event.target)) {
      handleHide();
    }
  };
  var handleClickOutside = function(event) {
    if (mobile && sidebarRef.current && !sidebarRef.current.contains(event.target)) {
      handleHide();
    }
  };
  var handleOnClick = function(event) {
    var target = event.target;
    target && target.classList.contains("nav-link") && !target.classList.contains("nav-group-toggle") && mobile && handleHide();
  };
  var _className = classNames("sidebar", (_b = {
    "sidebar-narrow": narrow,
    "sidebar-overlaid": overlaid
  }, _b["sidebar-".concat(position)] = position, _b["sidebar-".concat(size)] = size, _b["sidebar-narrow-unfoldable"] = unfoldable, _b.show = _visible === true && mobile, _b.hide = _visible === false && !mobile, _b), className);
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    import_react.default.createElement("div", __assign({ className: _className }, rest, { ref: forkedRef }), children2),
    typeof window !== "undefined" && mobile && (0, import_react_dom.createPortal)(import_react.default.createElement(CBackdrop, { className: "sidebar-backdrop", visible: _visible }), document.body)
  );
});
CSidebar.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  narrow: propTypes.exports.bool,
  onHide: propTypes.exports.func,
  onShow: propTypes.exports.func,
  onVisibleChange: propTypes.exports.func,
  overlaid: propTypes.exports.bool,
  position: propTypes.exports.oneOf(["fixed", "sticky"]),
  size: propTypes.exports.oneOf(["sm", "lg", "xl"]),
  unfoldable: propTypes.exports.bool,
  visible: propTypes.exports.bool
};
CSidebar.displayName = "CSidebar";
var CSidebarBrand = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("sidebar-brand", className);
  return import_react.default.createElement("div", __assign({ className: _className, ref }, rest), children2);
});
CSidebarBrand.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CSidebarBrand.displayName = "CSidebarBrand";
var CSidebarFooter = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("sidebar-footer", className);
  return import_react.default.createElement("div", __assign({ className: _className, ref }, rest), children2);
});
CSidebarFooter.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CSidebarFooter.displayName = "CSidebarFooter";
var CSidebarToggler = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("sidebar-toggler", className);
  return import_react.default.createElement("button", __assign({ className: _className, ref }, rest), children2);
});
CSidebarToggler.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CSidebarToggler.displayName = "CSidebarToggler";
var CSidebarHeader = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("sidebar-header", className);
  return import_react.default.createElement("div", __assign({ className: _className, ref }, rest), children2);
});
CSidebarHeader.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CSidebarHeader.displayName = "CSidebarHeader";
var CSpinner = (0, import_react.forwardRef)(function(_a, ref) {
  var className = _a.className, color = _a.color, _b = _a.component, Component = _b === void 0 ? "div" : _b, size = _a.size, _c = _a.variant, variant = _c === void 0 ? "border" : _c, _d = _a.visuallyHiddenLabel, visuallyHiddenLabel = _d === void 0 ? "Loading..." : _d, rest = __rest(_a, ["className", "color", "component", "size", "variant", "visuallyHiddenLabel"]);
  var _className = classNames("spinner-".concat(variant), "text-".concat(color), size && "spinner-".concat(variant, "-").concat(size), className);
  return import_react.default.createElement(
    Component,
    __assign({ className: _className, role: "status" }, rest, { ref }),
    import_react.default.createElement("span", { className: "visually-hidden" }, visuallyHiddenLabel)
  );
});
CSpinner.propTypes = {
  className: propTypes.exports.string,
  color: colorPropType,
  component: propTypes.exports.string,
  size: propTypes.exports.oneOf(["sm"]),
  variant: propTypes.exports.oneOf(["border", "grow"]),
  visuallyHiddenLabel: propTypes.exports.string
};
CSpinner.displayName = "CSpinner";
var CTableHead = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, color = _a.color, rest = __rest(_a, ["children", "className", "color"]);
  var _className = classNames((_b = {}, _b["table-".concat(color)] = color, _b), className);
  return import_react.default.createElement("thead", __assign({ className: _className ? _className : void 0 }, rest, { ref }), children2);
});
CTableHead.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType
};
CTableHead.displayName = "CTableHead";
var CTableHeaderCell = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, color = _a.color, rest = __rest(_a, ["children", "className", "color"]);
  var _className = classNames((_b = {}, _b["table-".concat(color)] = color, _b), className);
  return import_react.default.createElement("th", __assign({ className: _className ? _className : void 0 }, rest, { ref }), children2);
});
CTableHeaderCell.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType
};
CTableHeaderCell.displayName = "CTableHeaderCell";
var CTableBody = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, color = _a.color, rest = __rest(_a, ["children", "className", "color"]);
  var _className = classNames((_b = {}, _b["table-".concat(color)] = color, _b), className);
  return import_react.default.createElement("tbody", __assign({ className: _className ? _className : void 0 }, rest, { ref }), children2);
});
CTableBody.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType
};
CTableBody.displayName = "CTableBody";
var CTableDataCell = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, active = _a.active, align = _a.align, className = _a.className, color = _a.color, rest = __rest(_a, ["children", "active", "align", "className", "color"]);
  var _className = classNames((_b = {}, _b["align-".concat(align)] = align, _b["table-active"] = active, _b["table-".concat(color)] = color, _b), className);
  var Component = rest.scope ? "th" : "td";
  return import_react.default.createElement(Component, __assign({ className: _className ? _className : void 0 }, rest, { ref }), children2);
});
CTableDataCell.propTypes = {
  active: propTypes.exports.bool,
  align: propTypes.exports.oneOf(["bottom", "middle", "top"]),
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType
};
CTableDataCell.displayName = "CTableDataCell";
var CTableRow = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, active = _a.active, align = _a.align, className = _a.className, color = _a.color, rest = __rest(_a, ["children", "active", "align", "className", "color"]);
  var _className = classNames((_b = {}, _b["align-".concat(align)] = align, _b["table-active"] = active, _b["table-".concat(color)] = color, _b), className);
  return import_react.default.createElement("tr", __assign({ className: _className ? _className : void 0 }, rest, { ref }), children2);
});
CTableRow.propTypes = {
  active: propTypes.exports.bool,
  align: propTypes.exports.oneOf(["bottom", "middle", "top"]),
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType
};
CTableRow.displayName = "CTableRow";
var CTableFoot = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, className = _a.className, color = _a.color, rest = __rest(_a, ["children", "className", "color"]);
  var _className = classNames((_b = {}, _b["table-".concat(color)] = color, _b), className);
  return import_react.default.createElement("tfoot", __assign({ className: _className ? _className : void 0 }, rest, { ref }), children2);
});
CTableFoot.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType
};
CTableFoot.displayName = "CTableFoot";
var CTableCaption = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, props = __rest(_a, ["children"]);
  return import_react.default.createElement("caption", __assign({}, props, { ref }), children2);
});
CTableCaption.propTypes = {
  children: propTypes.exports.node
};
CTableCaption.displayName = "CTableCaption";
var CTableResponsiveWrapper = function(_a) {
  var children2 = _a.children, responsive = _a.responsive, rest = __rest(_a, ["children", "responsive"]);
  return responsive ? import_react.default.createElement("div", __assign({ className: typeof responsive === "boolean" ? "table-responsive" : "table-responsive-".concat(responsive) }, rest), children2) : children2;
};
CTableResponsiveWrapper.propTypes = {
  children: propTypes.exports.any,
  responsive: propTypes.exports.oneOfType([
    propTypes.exports.bool,
    propTypes.exports.oneOf(["sm", "md", "lg", "xl", "xxl"])
  ])
};
CTableResponsiveWrapper.displayName = "CTableResponsiveWrapper";
var CTable = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, align = _a.align, borderColor = _a.borderColor, bordered = _a.bordered, borderless = _a.borderless, caption = _a.caption, captionTop = _a.captionTop, className = _a.className, color = _a.color, columns = _a.columns, footer = _a.footer, hover = _a.hover, _c = _a.items, items = _c === void 0 ? [] : _c, responsive = _a.responsive, small = _a.small, striped = _a.striped, stripedColumns = _a.stripedColumns, tableFootProps = _a.tableFootProps, tableHeadProps = _a.tableHeadProps, rest = __rest(_a, ["children", "align", "borderColor", "bordered", "borderless", "caption", "captionTop", "className", "color", "columns", "footer", "hover", "items", "responsive", "small", "striped", "stripedColumns", "tableFootProps", "tableHeadProps"]);
  var _className = classNames("table", (_b = {}, _b["align-".concat(align)] = align, _b["border-".concat(borderColor)] = borderColor, _b["caption-top"] = captionTop || caption === "top", _b["table-bordered"] = bordered, _b["table-borderless"] = borderless, _b["table-".concat(color)] = color, _b["table-hover"] = hover, _b["table-sm"] = small, _b["table-striped"] = striped, _b["table-striped-columns"] = stripedColumns, _b), className);
  var rawColumnNames = columns ? columns.map(function(column) {
    if (typeof column === "object")
      return column.key;
    else
      return column;
  }) : Object.keys(items[0] || {}).filter(function(el) {
    return el.charAt(0) !== "_";
  });
  var pretifyName = function(name) {
    return name.replace(/[-_.]/g, " ").replace(/ +/g, " ").replace(/([a-z0-9])([A-Z])/g, "$1 $2").split(" ").map(function(word) {
      return word.charAt(0).toUpperCase() + word.slice(1);
    }).join(" ");
  };
  var label = function(column) {
    return typeof column === "object" ? column.label !== void 0 ? column.label : pretifyName(column.key) : pretifyName(column);
  };
  return import_react.default.createElement(
    CTableResponsiveWrapper,
    { responsive },
    import_react.default.createElement(
      "table",
      __assign({ className: _className }, rest, { ref }),
      (caption && caption !== "top" || captionTop) && import_react.default.createElement(CTableCaption, null, caption || captionTop),
      columns && import_react.default.createElement(
        CTableHead,
        __assign({}, tableHeadProps),
        import_react.default.createElement(CTableRow, null, columns.map(function(column, index) {
          return import_react.default.createElement(CTableHeaderCell, __assign({}, column._props && __assign({}, column._props), column._style && { style: __assign({}, column._style) }, { key: index }), label(column));
        }))
      ),
      items && import_react.default.createElement(CTableBody, null, items.map(function(item, index) {
        return import_react.default.createElement(CTableRow, __assign({}, item._props && __assign({}, item._props), { key: index }), rawColumnNames.map(function(colName, index2) {
          return item[colName] ? import_react.default.createElement(CTableDataCell, __assign({}, item._cellProps && __assign(__assign({}, item._cellProps["all"] && __assign({}, item._cellProps["all"])), item._cellProps[colName] && __assign({}, item._cellProps[colName])), { key: index2 }), item[colName]) : null;
        }));
      })),
      children2,
      footer && import_react.default.createElement(
        CTableFoot,
        __assign({}, tableFootProps),
        import_react.default.createElement(CTableRow, null, footer.map(function(item, index) {
          return import_react.default.createElement(CTableDataCell, __assign({}, item._props && __assign({}, item._props), { key: index }), typeof item === "object" ? item.label : item);
        }))
      )
    )
  );
});
CTable.propTypes = {
  align: propTypes.exports.oneOf(["bottom", "middle", "top"]),
  borderColor: propTypes.exports.string,
  bordered: propTypes.exports.bool,
  borderless: propTypes.exports.bool,
  caption: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.oneOf(["top"])]),
  captionTop: propTypes.exports.string,
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType,
  columns: propTypes.exports.array,
  footer: propTypes.exports.array,
  hover: propTypes.exports.bool,
  items: propTypes.exports.array,
  responsive: propTypes.exports.oneOfType([
    propTypes.exports.bool,
    propTypes.exports.oneOf(["sm", "md", "lg", "xl", "xxl"])
  ]),
  small: propTypes.exports.bool,
  striped: propTypes.exports.bool,
  stripedColumns: propTypes.exports.bool,
  tableFootProps: propTypes.exports.shape(__assign({}, CTableFoot.propTypes)),
  tableHeadProps: propTypes.exports.shape(__assign({}, CTableHead.propTypes))
};
CTable.displayName = "CTable";
var CTabContent = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("tab-content", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CTabContent.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CTabContent.displayName = "CTabContent";
var CTabPane = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, onHide = _a.onHide, onShow = _a.onShow, visible = _a.visible, rest = __rest(_a, ["children", "className", "onHide", "onShow", "visible"]);
  var tabPaneRef = (0, import_react.useRef)();
  var forkedRef = useForkedRef(ref, tabPaneRef);
  var getTransitionClass = function(state) {
    return state === "entered" && "show";
  };
  var _className = classNames("tab-pane", "fade", {
    active: visible
  }, className);
  return import_react.default.createElement(Transition, { in: visible, nodeRef: tabPaneRef, onEnter: onShow, onExit: onHide, timeout: 150 }, function(state) {
    var transitionClass = getTransitionClass(state);
    return import_react.default.createElement("div", __assign({ className: classNames(_className, transitionClass) }, rest, { ref: forkedRef }), children2);
  });
});
CTabPane.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  onHide: propTypes.exports.func,
  onShow: propTypes.exports.func,
  visible: propTypes.exports.bool
};
CTabPane.displayName = "CTabPane";
var CToastContext = (0, import_react.createContext)({});
var CToast = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var children2 = _a.children, _c = _a.animation, animation = _c === void 0 ? true : _c, _d = _a.autohide, autohide = _d === void 0 ? true : _d, className = _a.className, color = _a.color, _e = _a.delay, delay = _e === void 0 ? 5e3 : _e, index = _a.index, key = _a.key, _f = _a.visible, visible = _f === void 0 ? false : _f, onClose = _a.onClose, onShow = _a.onShow, rest = __rest(_a, ["children", "animation", "autohide", "className", "color", "delay", "index", "key", "visible", "onClose", "onShow"]);
  var toastRef = (0, import_react.useRef)();
  var forkedRef = useForkedRef(ref, toastRef);
  var _g = (0, import_react.useState)(false), _visible = _g[0], setVisible = _g[1];
  var timeout2 = (0, import_react.useRef)();
  (0, import_react.useEffect)(function() {
    setVisible(visible);
  }, [visible]);
  var contextValues = {
    visible: _visible,
    setVisible
  };
  (0, import_react.useEffect)(function() {
    return function() {
      return clearTimeout(timeout2.current);
    };
  }, []);
  (0, import_react.useEffect)(function() {
    _autohide();
  }, [_visible]);
  var _autohide = function() {
    if (autohide) {
      clearTimeout(timeout2.current);
      timeout2.current = window.setTimeout(function() {
        setVisible(false);
      }, delay);
    }
  };
  var _className = classNames("toast", (_b = {
    fade: animation
  }, _b["bg-".concat(color)] = color, _b["border-0"] = color, _b), className);
  var getTransitionClass = function(state) {
    return state === "entering" ? "showing" : state === "entered" ? "show" : state === "exiting" ? "showing" : "fade";
  };
  return import_react.default.createElement(Transition, { in: _visible, nodeRef: toastRef, onEnter: function() {
    return onShow && onShow(index ? index : null);
  }, onExited: function() {
    return onClose && onClose(index ? index : null);
  }, timeout: 250, unmountOnExit: true }, function(state) {
    var transitionClass = getTransitionClass(state);
    return import_react.default.createElement(
      CToastContext.Provider,
      { value: contextValues },
      import_react.default.createElement("div", __assign({ className: classNames(_className, transitionClass), "aria-live": "assertive", "aria-atomic": "true", role: "alert", onMouseEnter: function() {
        return clearTimeout(timeout2.current);
      }, onMouseLeave: function() {
        return _autohide();
      } }, rest, { key, ref: forkedRef }), children2)
    );
  });
});
CToast.propTypes = {
  animation: propTypes.exports.bool,
  autohide: propTypes.exports.bool,
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  color: colorPropType,
  delay: propTypes.exports.number,
  index: propTypes.exports.number,
  key: propTypes.exports.number,
  onClose: propTypes.exports.func,
  onShow: propTypes.exports.func,
  visible: propTypes.exports.bool
};
CToast.displayName = "CToast";
var CToastBody = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, rest = __rest(_a, ["children", "className"]);
  var _className = classNames("toast-body", className);
  return import_react.default.createElement("div", __assign({ className: _className }, rest, { ref }), children2);
});
CToastBody.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string
};
CToastBody.displayName = "CToastBody";
var CToastClose = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, Component = _a.component, rest = __rest(_a, ["children", "component"]);
  var setVisible = (0, import_react.useContext)(CToastContext).setVisible;
  return Component ? import_react.default.createElement(Component, __assign({ onClick: function() {
    return setVisible(false);
  } }, rest, { ref }), children2) : import_react.default.createElement(CCloseButton, __assign({ onClick: function() {
    return setVisible(false);
  } }, rest, { ref }));
});
CToastClose.propTypes = __assign(__assign({}, CCloseButton.propTypes), { component: propTypes.exports.elementType });
CToastClose.displayName = "CToastClose";
var CToastHeader = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, closeButton = _a.closeButton, rest = __rest(_a, ["children", "className", "closeButton"]);
  var _className = classNames("toast-header", className);
  return import_react.default.createElement(
    "div",
    __assign({ className: _className }, rest, { ref }),
    children2,
    closeButton && import_react.default.createElement(CToastClose, null)
  );
});
CToastHeader.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  closeButton: propTypes.exports.bool
};
CToastHeader.displayName = "CToastHeader";
var CToaster = (0, import_react.forwardRef)(function(_a, ref) {
  var children2 = _a.children, className = _a.className, placement = _a.placement, push = _a.push, rest = __rest(_a, ["children", "className", "placement", "push"]);
  var _b = (0, import_react.useState)([]), toasts = _b[0], setToasts = _b[1];
  var index = (0, import_react.useRef)(0);
  (0, import_react.useEffect)(function() {
    index.current++;
    push && addToast(push);
  }, [push]);
  var addToast = function(push2) {
    setToasts(function(state) {
      return __spreadArray(__spreadArray([], state, true), [
        import_react.default.cloneElement(push2, {
          index: index.current,
          key: index.current,
          onClose: function(index2) {
            return setToasts(function(state2) {
              return state2.filter(function(i) {
                return i.props.index !== index2;
              });
            });
          }
        })
      ], false);
    });
  };
  var _className = classNames("toaster toast-container p-3", {
    "position-fixed": placement,
    "top-0": placement && placement.includes("top"),
    "top-50 translate-middle-y": placement && placement.includes("middle"),
    "bottom-0": placement && placement.includes("bottom"),
    "start-0": placement && placement.includes("start"),
    "start-50 translate-middle-x": placement && placement.includes("center"),
    "end-0": placement && placement.includes("end")
  }, className);
  var toaster = function(ref2) {
    return toasts.length > 0 || children2 ? import_react.default.createElement(
      "div",
      __assign({ className: _className }, rest, { ref: ref2 }),
      children2,
      toasts.map(function(toast) {
        return import_react.default.cloneElement(toast, { visible: true });
      })
    ) : null;
  };
  return typeof window !== "undefined" && placement ? (0, import_react_dom.createPortal)(toaster(ref), document.body) : toaster(ref);
});
CToaster.propTypes = {
  children: propTypes.exports.node,
  className: propTypes.exports.string,
  placement: propTypes.exports.oneOfType([
    propTypes.exports.string,
    propTypes.exports.oneOf([
      "top-start",
      "top-center",
      "top-end",
      "middle-start",
      "middle-center",
      "middle-end",
      "bottom-start",
      "bottom-center",
      "bottom-end"
    ])
  ]),
  push: propTypes.exports.any
};
CToaster.displayName = "CToaster";
var CTooltip = function(_a) {
  var children2 = _a.children, content = _a.content, _b = _a.offset, offset2 = _b === void 0 ? [0, 0] : _b, onHide = _a.onHide, onShow = _a.onShow, _c = _a.placement, placement = _c === void 0 ? "top" : _c, _d = _a.trigger, trigger = _d === void 0 ? "hover" : _d, visible = _a.visible, rest = __rest(_a, ["children", "content", "offset", "onHide", "onShow", "placement", "trigger", "visible"]);
  var tooltipRef = (0, import_react.useRef)();
  var _e = (0, import_react.useState)(visible), _visible = _e[0], setVisible = _e[1];
  var _f = (0, import_react.useState)(null), referenceElement = _f[0], setReferenceElement = _f[1];
  var _g = (0, import_react.useState)(null), popperElement = _g[0], setPopperElement = _g[1];
  var _h = (0, import_react.useState)(null), arrowElement = _h[0], setArrowElement = _h[1];
  var _j = usePopper(referenceElement, popperElement, {
    modifiers: [
      { name: "arrow", options: { element: arrowElement } },
      {
        name: "offset",
        options: {
          offset: offset2
        }
      }
    ],
    placement
  }), styles = _j.styles, attributes = _j.attributes;
  var getTransitionClass = function(state) {
    return state === "entering" ? "fade" : state === "entered" ? "fade show" : state === "exiting" ? "fade" : "fade";
  };
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    import_react.default.cloneElement(children2, __assign(__assign(__assign({ ref: setReferenceElement }, (trigger === "click" || trigger.includes("click")) && {
      onClick: function() {
        return setVisible(!_visible);
      }
    }), (trigger === "focus" || trigger.includes("focus")) && {
      onFocus: function() {
        return setVisible(true);
      },
      onBlur: function() {
        return setVisible(false);
      }
    }), (trigger === "hover" || trigger.includes("hover")) && {
      onMouseEnter: function() {
        return setVisible(true);
      },
      onMouseLeave: function() {
        return setVisible(false);
      }
    })),
    typeof window !== "undefined" && (0, import_react_dom.createPortal)(import_react.default.createElement(Transition, { in: _visible, mountOnEnter: true, nodeRef: tooltipRef, onEnter: onShow, onExit: onHide, timeout: {
      enter: 0,
      exit: 200
    }, unmountOnExit: true }, function(state) {
      var transitionClass = getTransitionClass(state);
      return import_react.default.createElement(
        "div",
        __assign({ className: classNames("tooltip bs-tooltip-".concat(placement === "left" ? "start" : placement === "right" ? "end" : placement), transitionClass), ref: setPopperElement, role: "tooltip", style: styles.popper }, attributes.popper, rest),
        import_react.default.createElement("div", { className: "tooltip-arrow", style: styles.arrow, ref: setArrowElement }),
        import_react.default.createElement("div", { className: "tooltip-inner" }, content)
      );
    }), document.body)
  );
};
CTooltip.propTypes = {
  children: propTypes.exports.any,
  content: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  offset: propTypes.exports.any,
  onHide: propTypes.exports.func,
  onShow: propTypes.exports.func,
  placement: propTypes.exports.oneOf(["auto", "top", "right", "bottom", "left"]),
  trigger: triggerPropType,
  visible: propTypes.exports.bool
};
CTooltip.displayName = "CTooltip";
var CWidgetStatsA = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var action = _a.action, chart = _a.chart, className = _a.className, color = _a.color, title = _a.title, value = _a.value, rest = __rest(_a, ["action", "chart", "className", "color", "title", "value"]);
  var _className = classNames((_b = {}, _b["bg-".concat(color)] = color, _b["text-high-emphasis-inverse"] = color, _b), className);
  return import_react.default.createElement(
    CCard,
    __assign({ className: _className }, rest, { ref }),
    import_react.default.createElement(
      CCardBody,
      { className: "pb-0 d-flex justify-content-between align-items-start" },
      import_react.default.createElement(
        "div",
        null,
        value && import_react.default.createElement("div", { className: "fs-4 fw-semibold" }, value),
        title && import_react.default.createElement("div", null, title)
      ),
      action
    ),
    chart
  );
});
CWidgetStatsA.propTypes = {
  action: propTypes.exports.node,
  chart: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  className: propTypes.exports.string,
  color: colorPropType,
  title: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  value: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node, propTypes.exports.number])
};
CWidgetStatsA.displayName = "CWidgetStatsA";
var CWidgetStatsB = (0, import_react.forwardRef)(function(_a, ref) {
  var className = _a.className, color = _a.color, inverse = _a.inverse, progress = _a.progress, text = _a.text, title = _a.title, value = _a.value, rest = __rest(_a, ["className", "color", "inverse", "progress", "text", "title", "value"]);
  return import_react.default.createElement(
    CCard,
    __assign({ className, color }, inverse && { textColor: "high-emphasis-inverse" }, rest, { ref }),
    import_react.default.createElement(
      CCardBody,
      null,
      value && import_react.default.createElement("div", { className: "fs-4 fw-semibold" }, value),
      title && import_react.default.createElement("div", null, title),
      import_react.default.createElement(CProgress, __assign({ className: "my-2", height: 4 }, inverse && { white: true }, progress)),
      text && import_react.default.createElement("small", { className: inverse ? "text-medium-emphasis-inverse" : "text-medium-emphasis" }, text)
    )
  );
});
CWidgetStatsB.propTypes = {
  className: propTypes.exports.string,
  color: colorPropType,
  inverse: propTypes.exports.bool,
  progress: propTypes.exports.object,
  text: propTypes.exports.string,
  title: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  value: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node, propTypes.exports.number])
};
CWidgetStatsB.displayName = "CWidgetCWidgetStatsB";
var CWidgetStatsC = (0, import_react.forwardRef)(function(_a, ref) {
  var className = _a.className, color = _a.color, icon = _a.icon, inverse = _a.inverse, progress = _a.progress, title = _a.title, value = _a.value, rest = __rest(_a, ["className", "color", "icon", "inverse", "progress", "title", "value"]);
  return import_react.default.createElement(
    CCard,
    __assign({ className, color }, inverse && { textColor: "high-emphasis-inverse" }, rest, { ref }),
    import_react.default.createElement(
      CCardBody,
      null,
      icon && import_react.default.createElement("div", { className: "text-medium-emphasis".concat(inverse ? "-inverse" : "", " text-end mb-4") }, icon),
      value && import_react.default.createElement("div", { className: "text-high-emphasis".concat(inverse ? "-inverse" : "", " fs-4 fw-semibold") }, value),
      title && import_react.default.createElement("div", { className: inverse ? "text-medium-emphasis-inverse" : "text-medium-emphasis" }, title),
      import_react.default.createElement(CProgress, __assign({ className: "mt-3 mb-0", height: 4 }, inverse && { white: true }, progress))
    )
  );
});
CWidgetStatsC.propTypes = {
  className: propTypes.exports.string,
  color: colorPropType,
  icon: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  inverse: propTypes.exports.bool,
  progress: propTypes.exports.object,
  title: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  value: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node, propTypes.exports.number])
};
CWidgetStatsC.displayName = "CWidgetStatsCWidgetStatsC";
var CWidgetStatsD = (0, import_react.forwardRef)(function(_a, ref) {
  var _b;
  var className = _a.className, chart = _a.chart, color = _a.color, icon = _a.icon, values2 = _a.values, rest = __rest(_a, ["className", "chart", "color", "icon", "values"]);
  var _className = classNames(className);
  var classNameHeader = classNames("position-relative d-flex justify-content-center align-items-center", (_b = {}, _b["bg-".concat(color)] = color, _b));
  return import_react.default.createElement(
    CCard,
    __assign({ className: _className }, rest, { ref }),
    import_react.default.createElement(
      CCardHeader,
      { className: classNameHeader },
      icon,
      chart
    ),
    import_react.default.createElement(CCardBody, { className: "row text-center" }, values2 && values2.map(function(value, index) {
      return import_react.default.createElement(
        import_react.default.Fragment,
        { key: index },
        index % 2 !== 0 && import_react.default.createElement("div", { className: "vr" }),
        import_react.default.createElement(
          CCol,
          null,
          import_react.default.createElement("div", { className: "fs-5 fw-semibold" }, value.value),
          import_react.default.createElement("div", { className: "text-uppercase text-medium-emphasis small" }, value.title)
        )
      );
    }))
  );
});
CWidgetStatsD.propTypes = {
  chart: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  className: propTypes.exports.string,
  color: colorPropType,
  icon: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  values: propTypes.exports.arrayOf(propTypes.exports.any)
};
CWidgetStatsD.displayName = "CWidgetStatsD";
var CWidgetStatsE = (0, import_react.forwardRef)(function(_a, ref) {
  var chart = _a.chart, className = _a.className, title = _a.title, value = _a.value, rest = __rest(_a, ["chart", "className", "title", "value"]);
  var _className = classNames(className);
  return import_react.default.createElement(
    CCard,
    __assign({ className: _className }, rest, { ref }),
    import_react.default.createElement(
      CCardBody,
      { className: "text-center" },
      title && import_react.default.createElement("div", { className: "text-medium-emphasis small text-uppercase fw-semibold" }, title),
      value && import_react.default.createElement("div", { className: "fs-6 fw-semibold py-3" }, value),
      chart
    )
  );
});
CWidgetStatsE.propTypes = {
  children: propTypes.exports.node,
  chart: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  className: propTypes.exports.string,
  title: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  value: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node, propTypes.exports.number])
};
CWidgetStatsE.displayName = "CWidgetStatsE";
var CWidgetStatsF = (0, import_react.forwardRef)(function(_a, ref) {
  var className = _a.className, color = _a.color, footer = _a.footer, icon = _a.icon, _b = _a.padding, padding = _b === void 0 ? true : _b, title = _a.title, value = _a.value, rest = __rest(_a, ["className", "color", "footer", "icon", "padding", "title", "value"]);
  var _className = classNames(className);
  return import_react.default.createElement(
    CCard,
    __assign({ className: _className }, rest, { ref }),
    import_react.default.createElement(
      CCardBody,
      { className: "d-flex align-items-center ".concat(padding === false && "p-0") },
      import_react.default.createElement("div", { className: "me-3 text-white bg-".concat(color, " ").concat(padding ? "p-3" : "p-4") }, icon),
      import_react.default.createElement(
        "div",
        null,
        import_react.default.createElement("div", { className: "fs-6 fw-semibold text-".concat(color) }, value),
        import_react.default.createElement("div", { className: "text-medium-emphasis text-uppercase fw-semibold small" }, title)
      )
    ),
    footer && import_react.default.createElement(CCardFooter, null, footer)
  );
});
CWidgetStatsF.propTypes = {
  className: propTypes.exports.string,
  color: colorPropType,
  footer: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  icon: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  padding: propTypes.exports.bool,
  title: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node]),
  value: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.node, propTypes.exports.number])
};
CWidgetStatsF.displayName = "CWidgetStatsF";
export {
  CAccordion,
  CAccordionBody,
  CAccordionButton,
  CAccordionCollapse,
  CAccordionHeader,
  CAccordionItem,
  CAlert,
  CAlertHeading,
  CAlertLink,
  CAvatar,
  CBackdrop,
  CBadge,
  CBreadcrumb,
  CBreadcrumbItem,
  CButton,
  CButtonGroup,
  CButtonToolbar,
  CCallout,
  CCard,
  CCardBody,
  CCardFooter,
  CCardGroup,
  CCardHeader,
  CCardImage,
  CCardImageOverlay,
  CCardLink,
  CCardSubtitle,
  CCardText,
  CCardTitle,
  CCarousel,
  CCarouselCaption,
  CCarouselItem,
  CCloseButton,
  CCol,
  CCollapse,
  CContainer,
  CDropdown,
  CDropdownDivider,
  CDropdownHeader,
  CDropdownItem,
  CDropdownItemPlain,
  CDropdownMenu,
  CDropdownToggle,
  CFooter,
  CForm,
  CFormCheck,
  CFormFeedback,
  CFormFloating,
  CFormInput,
  CFormLabel,
  CFormRange,
  CFormSelect,
  CFormSwitch,
  CFormText,
  CFormTextarea,
  CHeader,
  CHeaderBrand,
  CHeaderDivider,
  CHeaderNav,
  CHeaderText,
  CHeaderToggler,
  CImage,
  CInputGroup,
  CInputGroupText,
  CLink,
  CListGroup,
  CListGroupItem,
  CModal,
  CModalBody,
  CModalContent,
  CModalDialog,
  CModalFooter,
  CModalHeader,
  CModalTitle,
  CNav,
  CNavGroup,
  CNavGroupItems,
  CNavItem,
  CNavLink,
  CNavTitle,
  CNavbar,
  CNavbarBrand,
  CNavbarNav,
  CNavbarText,
  CNavbarToggler,
  COffcanvas,
  COffcanvasBody,
  COffcanvasHeader,
  COffcanvasTitle,
  CPagination,
  CPaginationItem,
  CPlaceholder,
  CPopover,
  CProgress,
  CProgressBar,
  CRow,
  CSidebar,
  CSidebarBrand,
  CSidebarFooter,
  CSidebarHeader,
  CSidebarNav,
  CSidebarToggler,
  CSpinner,
  CTabContent,
  CTabPane,
  CTable,
  CTableBody,
  CTableCaption,
  CTableDataCell,
  CTableFoot,
  CTableHead,
  CTableHeaderCell,
  CTableRow,
  CToast,
  CToastBody,
  CToastClose,
  CToastHeader,
  CToaster,
  CTooltip,
  CWidgetStatsA,
  CWidgetStatsB,
  CWidgetStatsC,
  CWidgetStatsD,
  CWidgetStatsE,
  CWidgetStatsF
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=@coreui_react.js.map
